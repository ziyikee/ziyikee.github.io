<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>二.Redis安装配置</title>
    <link href="/2021/11/10/Redis%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <url>/2021/11/10/Redis%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis安装与配置"><a href="#Redis安装与配置" class="headerlink" title="Redis安装与配置"></a>Redis安装与配置</h1><ol><li><p>首先通过ssh远程连接服务器或在虚拟机中安装</p></li><li><p>执行命令：<code>wget https://download.redis.io/releases/redis-6.2.6.tar.gz</code>，下载压缩包到本地/opt目录下，如图：</p><p><img src="/2021/11/10/Redis%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/1.png" srcset="/img/loading.gif" lazyload alt="1"></p></li><li><p> 执行命令:<code>tar  -zxvf  redis-6.2.6.tat.gz </code>,将压缩包解压大当前目录</p></li><li><p>解压完成之后，可进入解压目录查看当前文件：</p><p><img src="/2021/11/10/Redis%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/2.png" srcset="/img/loading.gif" lazyload alt="2"></p><p>其中<code>redis.conf</code>为配置文件</p></li><li><p>基本环境安装与redis安装：</p><ul><li><p><code>yum install gcc-c++ </code>   安装 gcc 编译工具</p><p><img src="/2021/11/10/Redis%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/3.png" srcset="/img/loading.gif" lazyload alt="3"></p></li><li><p>在redis目录下执行<code>make</code>编译安装redis，可能会花费一定的时间，因为要安装一系列的环境</p><p><img src="/2021/11/10/Redis%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/4.png" srcset="/img/loading.gif" lazyload alt="4"></p><p><code>make</code>完成后会显示在src目录下增加了内容，可以继续使用<code>make</code>或<code>make install</code>进行检验，因为环境已经配置好，所以之后的<code>make</code>速度很快</p></li><li><p>redis的默认安装路径在<code>/usr/local/bin</code></p><p><img src="/2021/11/10/Redis%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/5.png" srcset="/img/loading.gif" lazyload alt="5"></p></li></ul></li><li><p> 将redis的配置文件复制到当前的程序目录下，新建一个目录<code>kconfig</code>，保存配置文件</p></li></ol><p>   <img src="/2021/11/10/Redis%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/6.png" srcset="/img/loading.gif" lazyload alt="6"></p><ol start="7"><li> redis默认不是后台启动的，需要修改配置文件，使用<code>vim  redis.conf</code>修改配置文件，将图中的选项由<code>no</code>修改为’yes’</li></ol><p>   <img src="/2021/11/10/Redis%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/7.png" srcset="/img/loading.gif" lazyload alt="7"></p><ol start="8"><li><p>经过上述配置之后，便可以启动redis服务，使用命令<code>redis-server /kconfig/redis.conf </code></p><p><img src="/2021/11/10/Redis%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/8.png" srcset="/img/loading.gif" lazyload alt="8"></p></li><li><p>启动redis客户端连接服务端，使用命令<code>redis-cli -p 6379</code>连接端口6379</p><p><img src="/2021/11/10/Redis%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/9.png" srcset="/img/loading.gif" lazyload alt="9"></p></li><li><p>查看redis的进程运行状态，使用命令<code>ps -ef |grep redis</code></p><p><img src="/2021/11/10/Redis%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/10.png" srcset="/img/loading.gif" lazyload alt="10"></p></li><li><p>如何关闭redis服务？在客户端执行<code>shutdown</code>命令关闭服务器，执行<code>exit</code>退出客户端</p><p><img src="/2021/11/10/Redis%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/11.png" srcset="/img/loading.gif" lazyload alt="11"></p></li></ol><h1 id="redis-benchmark"><a href="#redis-benchmark" class="headerlink" title="redis-benchmark"></a>redis-benchmark</h1><p>​    官方自带的性能测试工具，如何使用? <code>redis-benchmark  [option]  [option value]</code>，该命令在redis的目录下执行，而不是客户端的内部之灵，具体参数如下：</p><p><img src="/2021/11/10/Redis%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/13.png" srcset="/img/loading.gif" lazyload alt="12"></p><p>简单测试：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-comment"># 测试100个并发连接 100000个请求</span><br><span class="hljs-attribute">redis</span>-benchmark -h localhost -p <span class="hljs-number">6379</span> -c <span class="hljs-number">100</span> -n <span class="hljs-number">100000</span><br></code></pre></div></td></tr></table></figure><p>测试结果与分析：</p><p><img src="/2021/11/10/Redis%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/12.png" srcset="/img/loading.gif" lazyload alt="13"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.runoob.com/redis/redis-tutorial.html">Redis 教程 | 菜鸟教程 (runoob.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一.Redis概述</title>
    <link href="/2021/11/09/Redis%E6%A6%82%E8%BF%B0/"/>
    <url>/2021/11/09/Redis%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="一-Redis概述"><a href="#一-Redis概述" class="headerlink" title="一.Redis概述"></a>一.Redis概述</h1><h2 id="1-数据库发展演变"><a href="#1-数据库发展演变" class="headerlink" title="1. 数据库发展演变"></a>1. 数据库发展演变</h2><ol><li><p>单机Mysql的年代：</p><p><img src="/2021/11/09/Redis%E6%A6%82%E8%BF%B0/1.png" srcset="/img/loading.gif" lazyload alt="1"></p><p>起初网站访问量并不是很大，单个数据库就可以满足需求，且当时更多的使用静态网页Html，服务器并没有很大的压力，但是可能存在很多瓶颈:</p><ul><li>数据量如果太大，一个机器放不下</li><li>数据的索引(B+ Tree)，一个机器的内存也放不下</li><li>访问量(读写混合)，一个服务器承受不了</li></ul><p>出现以上问题的话，单机模式无法解决。</p></li><li><p>Memcached(缓存)+Mysql+垂直拆分(读写分离)</p><p><img src="/2021/11/09/Redis%E6%A6%82%E8%BF%B0/2.png" srcset="/img/loading.gif" lazyload alt="2"></p><p>我们采用读写分离，由一个库来进行写数据，其他数据库同步写库的数据，提供读数据服务。</p><p>当网站大部分时候都是在读时，每次都要查询数据库的话就很麻烦，因此希望减轻数据库的读压力，我们可以使用缓存(Cache)来缓解读压力。</p><p>发展过程：优化数据结构和索引—&gt;文件缓存(但文件读写(IO)压力增大，也会降低效率)—&gt;Memchched(当时的热门技术)。</p></li><li><p>分库分表 + 分库分表 + Mysql集群</p><p><img src="/2021/11/09/Redis%E6%A6%82%E8%BF%B0/3.png" srcset="/img/loading.gif" lazyload alt="3"></p><p>尽管实现了分库分表，但是由于数据类型，数据量的增加(地图定位，音乐，热榜等数据)</p><p>Mysql等关系型数据库就不够用了，数据量很多，变化很大，例如给一个10万行的数据增加一个列属性，将需要修改所有10万条数据。</p><p>如果使用Mysql来存储比较大的文件，博客，图片等，数据库的表将会变得很大，效率也会降低，如果有一种数据库专门来处理这种数据，Mysql的压力就会变得十分小。</p></li><li><p>当前时代的互联网项目</p><p><img src="/2021/11/09/Redis%E6%A6%82%E8%BF%B0/4.png" srcset="/img/loading.gif" lazyload alt="4"></p></li></ol><h2 id="2-什么是NoSQL？"><a href="#2-什么是NoSQL？" class="headerlink" title="2. 什么是NoSQL？"></a>2. 什么是NoSQL？</h2><h3 id="2-1-NoSQL定义"><a href="#2-1-NoSQL定义" class="headerlink" title="2.1 NoSQL定义"></a>2.1 NoSQL定义</h3><p>​    NoSQL = Not  Only  SQL(不仅仅是SQL)</p><p>​    泛指非关系型数据库，随着Web2.0互联网的诞生，传统的关系型数据库很难应对Web2.0时代。尤其是超大规模的高并发社区，暴露出    很多难以克服的问题。NoSQL在当今大数据环境下发展十分迅速，Redis是发展最快的，也是我们当下必须要掌握的技术。</p><p>​    很多数据类型用户的个人信息，社交网络，地理位置，这些数据类型的存储不需要一个特定的格式，不需要多少的操作就可以横向扩展    的。例如可以使用Map&lt;String,Object&gt;键值对来存储。而关系型数据库中的数据一般以表格的形式存在，具有固定的行和列。</p><h3 id="2-2-NoSQL特点"><a href="#2-2-NoSQL特点" class="headerlink" title="2.2 NoSQL特点"></a>2.2 NoSQL特点</h3><p>​    <strong>解耦！</strong></p><ol><li><p>方便扩展（数据之间没有关系，很好扩展）</p></li><li><p>大数据量的高性能（Redis一秒写8万次，读取11万次，NoSQL的缓存记录级，是一种细粒度的缓存，性能会比较高）</p></li><li><p>数据类型是多样性的（不需要实现设计数据库，随取随用，如果数据量很大，设计表结构是很难的）</p></li><li><p>传统RDBMS与NoSQL的对比</p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc">传统的RDBMS：<br><span class="hljs-bullet">- </span>结构化组织<br><span class="hljs-bullet">- </span>SQL<br><span class="hljs-bullet">- </span>数据与关系都存储在单独的表中<br><span class="hljs-bullet">- </span>具有操作语言，数据定义语言<br><span class="hljs-bullet">- </span>严格的一致性<br><span class="hljs-bullet">- </span>基础的事务<br><span class="hljs-bullet">- </span>......<br></code></pre></div></td></tr></table></figure><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc">NoSQL:<br><span class="hljs-bullet">- </span>不仅仅是数据<br><span class="hljs-bullet">- </span>没有固定的查询语言，可以定义语法<br><span class="hljs-bullet">- </span>键值对存储，列存储，文档存储，图形数据库（社交关系存储）<br><span class="hljs-bullet">- </span>最终一致性<br><span class="hljs-bullet">- </span>CAP定理和BASE（异地多活）<br><span class="hljs-bullet">- </span>高性能，高可用，高可扩展<br><span class="hljs-bullet">- </span>.....<br></code></pre></div></td></tr></table></figure></li><li><p>3v：海量，多样，实时（大数据时代面临的问题）</p><p> 3高：高并发，高可扩，高xingneng </p></li></ol><h2 id="3-NoSQL四大分类"><a href="#3-NoSQL四大分类" class="headerlink" title="3. NoSQL四大分类"></a>3. NoSQL四大分类</h2><ol><li><p>KV键值对：Redis，Tair，Memcached….</p></li><li><p>文档型数据库（bson格式，与json相同）：</p><ul><li>MongoDB：<ul><li>一个基于分布式文件存储的数据库，c++编写，主要用于处理大量的文档。</li><li>一个介于关系型数据库和非关系型数据库中间的产品，是非关系行数据库中功能最丰富，最像关系型数据库的。</li></ul></li><li>ConthDB</li></ul></li><li><p>列存储数据库：HBase，分布式文件系统</p></li><li><p>图关系数据库(使用图结构存储关系)</p><p><img src="/2021/11/09/Redis%E6%A6%82%E8%BF%B0/5.png" srcset="/img/loading.gif" lazyload alt="图关系"></p></li></ol><p><strong>四种类型对比:</strong></p><p><img src="/2021/11/09/Redis%E6%A6%82%E8%BF%B0/6.png" srcset="/img/loading.gif" lazyload alt="四种NoSQL数据库对比"></p><h2 id="4-Redis简介"><a href="#4-Redis简介" class="headerlink" title="4. Redis简介"></a>4. Redis简介</h2><ul><li><p>Redis(Remote Dictionary Server)，远程字典服务。</p></li><li><p>是一个开源的使用ANSI <a href="https://baike.baidu.com/item/C%E8%AF%AD%E8%A8%80">C语言</a>编写、支持网络、可基于内存亦可持久化的日志型、Key-Value<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93/103728">数据库</a>，并提供多种语言的API。</p></li><li><p>功能</p><ul><li>内存存储，持久化，内存中是断电即失，因此需要做持久化（rbd，aof   ???)</li><li>效率高，可用于高速缓存</li><li>发布订阅系统</li><li>地图信息分析</li><li>计时器，计数器（统计浏览量…）</li><li>……</li></ul></li><li><p>特性</p><ul><li>多样的数据类型</li><li>持久化</li><li>集群</li><li>事务</li><li>…….</li></ul></li><li><p>参考</p><ul><li><a href="https://redis.io/">Redis官网</a></li><li><a href="http://www.redis.cn/">Redis中文官网</a></li></ul></li><li><p>一般在Linux服务器上部署Redis</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo常用操作</title>
    <link href="/2021/11/09/Hexo%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <url>/2021/11/09/Hexo%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="Hexo框架操作"><a href="#Hexo框架操作" class="headerlink" title="Hexo框架操作"></a>Hexo框架操作</h2><ul><li>hexo -clean    清除旧文件</li><li>hexo -g           生成最新</li><li>hexo -d          提交</li><li>hexo -s          启动本地预览</li><li>ssh -T  <a href="mailto:&#103;&#105;&#x74;&#x40;&#x67;&#x69;&#116;&#104;&#x75;&#x62;&#x2e;&#99;&#111;&#109;">&#103;&#105;&#x74;&#x40;&#x67;&#x69;&#116;&#104;&#x75;&#x62;&#x2e;&#99;&#111;&#109;</a>    验证是否与服务器连接成功</li></ul><h2 id="Front-matter变量"><a href="#Front-matter变量" class="headerlink" title="Front-matter变量"></a>Front-matter变量</h2><ul><li>title    文章标题</li><li>index_img     首页显示图片</li><li>date    日期</li><li>hide    文章是否隐藏</li><li>tags      文章标签</li><li>categories    分类</li><li>sticky    优先级，数值越大越靠前</li><li>top    与sticky功能一致</li><li>banner_img    文章页顶部放大图，图片路径为（/img/name.jpg）</li><li>excerpt    摘要，首页显示</li></ul><h2 id="添加便签"><a href="#添加便签" class="headerlink" title="添加便签"></a>添加便签</h2><p>​    在markdown中使用如下代码添加便签：</p><figure class="highlight mel"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mel">&#123;% note success %&#125;   <span class="hljs-comment">//单独一行，success为便签类别，具体种类如下</span><br>文字 或者 <span class="hljs-string">`markdown`</span> 均可<br>&#123;% endnote %&#125;    <span class="hljs-comment">//单独一行</span><br></code></pre></div></td></tr></table></figure><p>​    便签种类如下：<img src="/2021/11/09/Hexo%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/1.png" srcset="/img/loading.gif" lazyload alt="便签种类"></p><h2 id="行内便签"><a href="#行内便签" class="headerlink" title="行内便签"></a>行内便签</h2><p>​    在markdown中加入如下代码来使用Lable:</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">&#123;% label <span class="hljs-keyword">primary</span> @<span class="hljs-type">text</span> %&#125; //label  ***为便签种类，@+<span class="hljs-type">text</span>为显示文字，但<span class="hljs-type">text</span>不能以@开头<br></code></pre></div></td></tr></table></figure><p>​    Lable种类如下：</p><p>​    <span class="label label-primary">primary</span> <span class="label label-default">default</span> <span class="label label-info">info</span> <span class="label label-success">success</span> <span class="label label-warning">warning</span> <span class="label label-danger">danger</span></p><p>​    示例：写下代码<code>&#123;% label primary @12345 %&#125;</code>，将会出现一个Lable：<span class="label label-primary">12345</span></p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>欢迎到访！</title>
    <link href="/2021/11/09/%E6%AC%A2%E8%BF%8E%E5%88%B0%E8%AE%BF%EF%BC%81/"/>
    <url>/2021/11/09/%E6%AC%A2%E8%BF%8E%E5%88%B0%E8%AE%BF%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p><strong>所谓理想，只是同时拥有实力的人才能说的“现实”。</strong></p>          </div><h1 id="本站更新记录"><a href="#本站更新记录" class="headerlink" title="本站更新记录"></a>本站更新记录</h1><h2 id="2021-11-9"><a href="#2021-11-9" class="headerlink" title="2021.11.9"></a>2021.11.9</h2><ul><li>字体修改完成，教程在下面</li><li>增加ICP备案号</li></ul><h2 id="2021-11-6"><a href="#2021-11-6" class="headerlink" title="2021.11.6"></a>2021.11.6</h2><ul><li>利用hexo-asset-image插件解决了图片上传的问题，具体见文章</li><li>为域名加上了SSL证书（阿里云可免费申请，百度教程，很快解决），并在github上设置pages为强制HTTPS，这样就算输入HTTP，也会强转为HTTPS，终于是一个安全的站点了</li></ul><h2 id="2021-10-20"><a href="#2021-10-20" class="headerlink" title="2021.10.20"></a>2021.10.20</h2><ul><li>增加了运行时间</li><li>增加了转载版权标识（链接内容有问题，未解决）</li><li>页面底部内容修改</li><li>字体修改：参考：<a href="https://bestzuo.cn/posts/notoserifsc.html">博客网站字体设置：思源宋体 (bestzuo.cn)</a>，<a href="https://www.erenship.com/posts/40222.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93">Hexo’s Fluid 主题私人定制（持续更新） - Eren の 宇宙船 (erenship.com)</a></li></ul><h2 id="2021-10-19"><a href="#2021-10-19" class="headerlink" title="2021.10.19"></a>2021.10.19</h2><ul><li>完善个人信息</li><li>增加了网页访问量统计</li><li>发现首页的文章是可以配图的（原来不是主题不好，是我太菜不会用π_π）</li><li>不会加评论功能。。。</li><li>woc，两个小时候评论功能成功了，其实设置好简单。。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo解决图片链接问题</title>
    <link href="/2021/11/06/hexo%E8%A7%A3%E5%86%B3%E5%9B%BE%E7%89%87%E9%93%BE%E6%8E%A5%E9%97%AE%E9%A2%98/"/>
    <url>/2021/11/06/hexo%E8%A7%A3%E5%86%B3%E5%9B%BE%E7%89%87%E9%93%BE%E6%8E%A5%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>在使用 Hexo 撰写博文时，时常需要将图片嵌入 md 文章中，但往往由于图片保存在本地主机，因此在网页中链接图片时，会无法获取本地主机的图片，导致图片不正常显示，在这里我通过使用Hexo插件的方式，保证图片可以正常上传。</p><ol><li><p>首先安装一个图片路径转换的插件：<code>hexo-asset-image</code>，在Hexo主文件夹下使用如下命令：</p><p><code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code></p></li><li><p> 打开_config.yml文件，将<code>post_asset_folder: false</code>修改为<code>true</code></p></li><li><p> 由于该插件本身可能会存在一下Bug，因此将<code>/node_modules/hexo-asset-image/index.js</code>文件的内容更改为如下代码：</p></li></ol>   <figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-keyword">var</span> cheerio = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cheerio&#x27;</span>);<br><br><span class="hljs-comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPosition</span>(<span class="hljs-params">str, m, i</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> str.split(m, i).join(m).length;<br>&#125;<br><br><span class="hljs-keyword">var</span> version = <span class="hljs-built_in">String</span>(hexo.version).split(<span class="hljs-string">&#x27;.&#x27;</span>);<br>hexo.extend.filter.register(<span class="hljs-string">&#x27;after_post_render&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;<br>  <span class="hljs-keyword">var</span> config = hexo.config;<br>  <span class="hljs-keyword">if</span>(config.post_asset_folder)&#123;<br>    <span class="hljs-keyword">var</span> link = data.permalink;<br><span class="hljs-keyword">if</span>(version.length &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">Number</span>(version[<span class="hljs-number">0</span>]) == <span class="hljs-number">3</span>)<br>   <span class="hljs-keyword">var</span> beginPos = getPosition(link, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span><br>   <span class="hljs-keyword">var</span> beginPos = getPosition(link, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-number">3</span>) + <span class="hljs-number">1</span>;<br><span class="hljs-comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span><br><span class="hljs-keyword">var</span> endPos = link.lastIndexOf(<span class="hljs-string">&#x27;/&#x27;</span>) + <span class="hljs-number">1</span>;<br>    link = link.substring(beginPos, endPos);<br><br>    <span class="hljs-keyword">var</span> toprocess = [<span class="hljs-string">&#x27;excerpt&#x27;</span>, <span class="hljs-string">&#x27;more&#x27;</span>, <span class="hljs-string">&#x27;content&#x27;</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; toprocess.length; i++)&#123;<br>      <span class="hljs-keyword">var</span> key = toprocess[i];<br> <br>      <span class="hljs-keyword">var</span> $ = cheerio.load(data[key], &#123;<br>        <span class="hljs-attr">ignoreWhitespace</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">xmlMode</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">lowerCaseTags</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">decodeEntities</span>: <span class="hljs-literal">false</span><br>      &#125;);<br><br>      $(<span class="hljs-string">&#x27;img&#x27;</span>).each(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">if</span> ($(<span class="hljs-built_in">this</span>).attr(<span class="hljs-string">&#x27;src&#x27;</span>))&#123;<br><span class="hljs-comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span><br><span class="hljs-keyword">var</span> src = $(<span class="hljs-built_in">this</span>).attr(<span class="hljs-string">&#x27;src&#x27;</span>).replace(<span class="hljs-string">&#x27;\\&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>);<br><span class="hljs-keyword">if</span>(!<span class="hljs-regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;<br>   !<span class="hljs-regexp">/^\s*\//</span>.test(src)) &#123;<br>  <span class="hljs-comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span><br>  <span class="hljs-comment">// In addition, to support multi-level local directory.</span><br>  <span class="hljs-keyword">var</span> linkArray = link.split(<span class="hljs-string">&#x27;/&#x27;</span>).filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">elem</span>)</span>&#123;<br><span class="hljs-keyword">return</span> elem != <span class="hljs-string">&#x27;&#x27;</span>;<br>  &#125;);<br>  <span class="hljs-keyword">var</span> srcArray = src.split(<span class="hljs-string">&#x27;/&#x27;</span>).filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">elem</span>)</span>&#123;<br><span class="hljs-keyword">return</span> elem != <span class="hljs-string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="hljs-string">&#x27;.&#x27;</span>;<br>  &#125;);<br>  <span class="hljs-keyword">if</span>(srcArray.length &gt; <span class="hljs-number">1</span>)<br>srcArray.shift();<br>  src = srcArray.join(<span class="hljs-string">&#x27;/&#x27;</span>);<br>  $(<span class="hljs-built_in">this</span>).attr(<span class="hljs-string">&#x27;src&#x27;</span>, config.root + link + src);<br>  <span class="hljs-built_in">console</span>.info&amp;&amp;<span class="hljs-built_in">console</span>.info(<span class="hljs-string">&quot;update link as:--&gt;&quot;</span>+config.root + link + src);<br>&#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">console</span>.info&amp;&amp;<span class="hljs-built_in">console</span>.info(<span class="hljs-string">&quot;no src attr, skipped...&quot;</span>);<br><span class="hljs-built_in">console</span>.info&amp;&amp;<span class="hljs-built_in">console</span>.info($(<span class="hljs-built_in">this</span>));<br>&#125;<br>      &#125;);<br>      data[key] = $.html();<br>    &#125;<br>  &#125;<br>&#125;);<br><br><br></code></pre></div></td></tr></table></figure><ol start="4"><li><p>尝试新建一个md文件，插件会自动在_post目录下生成一个与md文件同名的目录，之后向md文件中加入图片时，需要将该图片先放到同名目录下，然后使用图片链接加入图片，实例：</p><ul><li><p><code>hexo -new &quot;hexo解决图片链接问题&quot;</code></p></li><li><p>接下来会看到_post目录下生成了md文件和同名的文件夹，如图：<img src="/2021/11/06/hexo%E8%A7%A3%E5%86%B3%E5%9B%BE%E7%89%87%E9%93%BE%E6%8E%A5%E9%97%AE%E9%A2%98/1.png" srcset="/img/loading.gif" lazyload alt="生成结果"></p></li><li><p>使用规定的图片链接语法便可以链接图片：<code>[生成结果](1.png)</code>，不需要写路径，插件可以自己转换，只需要把图片名写出来就行。</p></li></ul><p>参考链接：</p><p>​    <a href="https://blog.csdn.net/xjm850552586/article/details/84101345?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.no_search_link"> hexo引用本地图片无法显示_Ericam_-CSDN博客_hexo 图片</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KING OF HEART</title>
    <link href="/2021/11/06/KING-OF-HEART/"/>
    <url>/2021/11/06/KING-OF-HEART/</url>
    
    <content type="html"><![CDATA[<ul><li>请别再唤我为孤独之人.</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Add Domain</title>
    <link href="/2021/10/23/add-domain/"/>
    <url>/2021/10/23/add-domain/</url>
    
    <content type="html"><![CDATA[<h1 id="域名添加"><a href="#域名添加" class="headerlink" title="域名添加"></a>域名添加</h1><p>​    在成功配置好博客并部署在github上之后，我们可以通过<code>xxxxx.github.io</code>的方式去访问博客，但是我想为自己的博客配置一个自己    的域名，例如本博客的域名：<a href="www.ziyikee.fun">www.ziyikee.fun</a> ,因此便需要去配置一个自己想要的域名。</p><p>​    首先需要在阿里云或腾讯云等厂商那里去买一个域名，比如我的域名是在阿里云上购买的，在购买域名之后，本来以为需要对域名进行    备案才可以使用该域名，然而在进行IPC备案时，对域名备案又需要备案服务码，你必须有自己的服务器才能获得这个备案服务码，因    此我一直以为还需要再买一台服务器才行，但是由于我的博客是直接部署在github上的，并不需要自己配置服务器，现在也没有使用服    务器的需求（服务器贵的一批），所以我以为配置域名估计要gg了。</p><p>​    但是在知乎查教程发现，将一个域名指向另一个域名其实并不需要备案（π—π），只需要下面几步简单的操作就行了：</p><ul><li><p>首先要购买一个域名，各大厂商都有卖，直接百度搜索即可</p></li><li><p>在域名管理处进行域名解析，添加两条新的记录</p><ol><li>记录类型为：CNAME（将一个域名执行另一个域名），主机记录为：www，记录值为：xxxxx.github.io，保存记录</li><li>记录类型为：CNAME（将一个域名执行另一个域名），主机记录为：@，记录值为：xxxxx.github.io，保存记录</li></ol></li></ul><ul><li><p>之后再本地hexo的source目录下，新建一个CNAME文件，文件内容为你的域名，如ziyikee.fun，保存文件</p></li><li><p>hexo g   hexo d，部署到github之后，便可以通过你的域名直接访问博客。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>背包九讲-自译版背包</title>
    <link href="/2021/10/18/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2-%E8%87%AA%E8%AF%91%E7%89%88/"/>
    <url>/2021/10/18/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2-%E8%87%AA%E8%AF%91%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h1 id="背包九讲—自译版"><a href="#背包九讲—自译版" class="headerlink" title="背包九讲—自译版"></a>背包九讲—自译版</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>所谓自译版，就是将某崔大神的背包九讲，用自己理解的意思抄一遍π﹏π（基本结构与内容与原版一致），在最初理解背包问题时，感觉十分难懂，看半天不知所云，因此本文用自己更容易理解的语言复述一遍“背包九讲”，方便日后复习时更方便快捷。</p><h2 id="1-01背包问题"><a href="#1-01背包问题" class="headerlink" title="1.01背包问题"></a>1.01背包问题</h2><p><strong>题目</strong></p><p>有N件物品和一个容量为V的背包。放入第i件物品所占用的容量是c [ i ] ，得到的价值是w [ i ] ,求将哪些物品装入背包可使价值总和最大.（简单来说，就是怎么在容量有限的情况下，使得这个背包里的物品价值总和最大）。</p><p><strong>基本思路</strong></p><p>这是最基础的背包问题，特点是：每件物品仅有一件，可以选择放或不放（这一条件在后面背包问题的延伸中会有所变化，这里是最典型最基础的背包问题。</p><p>用子问题定义状态：即f [ i ] [ j ]表示前  i 件物品恰放入一个容量为  j 的背包可以获得的最大价值（这里原文中使用了“恰”，但实际并不需要正好装满，在初始化可以区分开这两种情况，下文有提及）。则其状态转移方程便是：</p><figure class="highlight inform7"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs inform7">f<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>=max(f<span class="hljs-comment">[i−1]</span><span class="hljs-comment">[j]</span>,f<span class="hljs-comment">[i−1]</span><span class="hljs-comment">[j−c<span class="hljs-comment">[i]</span>]</span>+w<span class="hljs-comment">[i]</span>)<br></code></pre></div></td></tr></table></figure><p>这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生出来的，因此有必要详细解释一下：“将前 i 件物品放入容量为 j 的背包中”这个子问题，若只考虑第 i 件物品的策略（放或不放），那么就可以转化为一个只与前 i - 1 件物品的问题。如果不放第 i 件物品，那么就转化为“前 i- 1 件物品放入容量为 j 的背包中”，其最大价值为 <em>f</em> [i-1] [j]; 如果放第 i 件物品，那么问题就转化为“前 i -1件物品放入剩下的容量为 j - c[j]的背包中”，此时能获取的最大价值就是 <em>f</em> [i-1] [ j - c[ i ]]再加上第 i 件物品获得的价值 w[i]。其伪代码如下：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">F</span>[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>..V ] ← <span class="hljs-number">0</span> //初始值为<span class="hljs-number">0</span>，这与具体问题有关，下面会详细解释<br><span class="hljs-attribute">for</span> i ← <span class="hljs-number">1</span> to N //第<span class="hljs-number">1</span>个装入V，第<span class="hljs-number">2</span>个装入V......<br><span class="hljs-attribute">for</span> v ← Ci to V //第i个装入v，装入v-<span class="hljs-number">1</span>.....<br><span class="hljs-attribute">F</span>[i, v] ← max&#123;F[i − <span class="hljs-number">1</span>, v], F[i − <span class="hljs-number">1</span>, v − Ci] + Wi&#125;<br><br></code></pre></div></td></tr></table></figure><p><strong>优化空间复杂度</strong></p><p>上述方法的时间和空间复杂度均为<em>O</em>（V *N）,其中时间复杂度已经无法继续优化，但空间复杂度可以优化到 <em>O</em>(N)。</p><p>因为每次循环的内部都是：<code>f[i][j]=max(f[i−1][j],f[i−1][j−c[i]]+w[i])</code>，因此在外层循环中，是变量i在已知进行+1的循环，那么如果我们只用<em>f</em> [ j ]用来表示每次循环时，当前循环第 i 次时向容量为 j 的背包中进行选择（针对第 i 个物品放与不放的选择），那么上一次循环（第 i -1次，第 i - 1个物品）计算的结果，到当前循环（第 i 次，第 i 个物品）时，在第二次循环到 j 时，我们的 <em>f</em> [ j ]的值，其实就是 <em>f</em> [ i-1] [ j ]，<em>f</em> [ j - c[i]]的值其实就是上一轮的 <em>f</em> [ i-1] [ j - c[i]]，因此如果我们在第二层循环中使用倒序：j 从V到 c [ i ]，那么我们在计算时，就可以利用上一轮的计算值，将循环语句改为：<code> f[j] = max(f[j], f[j - c[i]] + w[i]);</code>，因为是倒序，所以在未改变前面的值之前，他们保存的是上一轮（第 i - 1轮）的结果，所以核心代码可优化为：</p><figure class="highlight inform7"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs inform7">for (int i = 1; i &lt;= n; i++)<br>    for (int j = V; j &gt;= c<span class="hljs-comment">[i]</span>; j--)<br>        f<span class="hljs-comment">[j]</span> = max(f<span class="hljs-comment">[j]</span>, f<span class="hljs-comment">[j - c<span class="hljs-comment">[i]</span>]</span> + w<span class="hljs-comment">[i]</span>);<br></code></pre></div></td></tr></table></figure><p>因为每次循环都要利用上一次循环运算结果前面的那些值（ j 要用到上一次的 j 和 j - c [i] )，所以要使用倒序来利用上一轮的值，如果使用顺序的话，当前值改变之后，后面的值就无法利用当前值上一轮的结果了，因为已经发生了改变。</p><p><strong>初始化的细节问题</strong></p><p>这里有一个很巧妙的问题，就是在初始化<em>f</em> [ 0 ] [ j ] ( j 从 0 到 V) 或 <em>f</em> [ j ] ( j 从 0 到 V ) 时，是初始化为 0 还是初始化为 负无穷，这两个值其实是针对不同的问题的：</p><ul><li>如果我们要求最终恰好装满背包，那么除了<em>f</em> [ 0 ]以外的数组值，其初始化的值应该设置为负无穷；</li></ul><ul><li>如果我们要求在背包容量的限制下装价值最大就行，并不要求装满，那么初始化的值应该设置为 0；</li></ul><p>造成该差别的原因依然在循环语句中，我们可以仔细分析一下这句：</p><figure class="highlight inform7"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs inform7">f<span class="hljs-comment">[j]</span> = max(f<span class="hljs-comment">[j]</span>, f<span class="hljs-comment">[j - c<span class="hljs-comment">[i]</span>]</span> + w<span class="hljs-comment">[i]</span>);<br></code></pre></div></td></tr></table></figure><p>当我们把值设为负无穷时，在最初，<em>f</em> [ j ]是负无穷，当我们装入第 i 件物品时，如果恰好装满，那么此时 j  - c [ i ] 等于0，这个时候才可以利用 <em>f</em> [0] = 0，再加上w[i]，使得<em>f</em> [ j ]的值被更新为正的，才能保证后续也恰好装满的时候，值为正的。倘若不能恰好装满，我们是没有办法凑出所有 i 的容量加起来等于V，那么在循环过程中 j  - c [ i ] 永远无法等于0，那就算加上了w[ i ]，也是在负无穷上加一个数还是负的，因此只有恰好装满时，最后再能得到正的价值值。</p><p>但如果我们将初始值都设置为 0 时，不管有没有恰好装满，只要可以装进去就行，我们就能在f[j] 和f[j - c[i]]之间选择一个最大的，即在当前容量下，针对 i 件物品所能装的最大价值值，这时是否恰好装满将不再产生影响。</p><p><strong>小结</strong></p><p>01背包问题是最基本的背包问题，它包含了背包问题中设计状态、方程的最基本思想，另外，别的类型的背包问题往往也可以转换成01背包问题求解。故一定要仔细体会上面基本思路的得出方法，状态转移方程的意义，以及最后怎样优化的空间复杂度。</p><p><strong>例题</strong></p><p><a href="https://www.acwing.com/problem/content/2/">AcWing 01背包问题</a><br><a href="https://www.luogu.org/problemnew/show/P2925">Luogu P2925干草出售</a><br><a href="https://www.luogu.org/problemnew/show/P1616">Luogu P1616疯狂的采药</a><br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3466">HDU 3466 Proud Merchants</a></p><h2 id="2-完全背包问题（待补充）"><a href="#2-完全背包问题（待补充）" class="headerlink" title="2.完全背包问题（待补充）"></a>2.完全背包问题（待补充）</h2><h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="https://blog.csdn.net/yandaoqiusheng/article/details/84782655">背包九讲通俗易懂版—我就是抄人家的，写的真好</a></p>]]></content>
    
    
    <categories>
      
      <category>算法与刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>背包问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自旋锁</title>
    <link href="/2021/10/18/%E8%87%AA%E6%97%8B%E9%94%81/"/>
    <url>/2021/10/18/%E8%87%AA%E6%97%8B%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h1><h2 id="1-提出背景："><a href="#1-提出背景：" class="headerlink" title="1.提出背景："></a>1.提出背景：</h2><p>​    由于多处理器环境中，某些资源的有限性，对于多个线程共享的资源进行访问时，需要进行互斥访问，便需要引入锁的概念，只有获取了锁的线程才可以对资源进行访问，由于多线程的核心是CPU的时间分片，所以同一时刻只能有一个线程获取锁。</p><p>​    当锁没有被占用时，尝试获取锁的线程成功获取到锁，之后若有另外的线程尝试获取锁，通常有两种处理方式：</p><p>​        1.没有获取到锁的线程就一直循环等待判断该资源是否已经释放锁，这种锁叫做自旋锁。</p><p>​        2.没有获取到锁的线程将自己阻塞起来，等待重新调度请求，这种锁叫互斥锁。</p><h2 id="2-自旋锁的定义"><a href="#2-自旋锁的定义" class="headerlink" title="2.自旋锁的定义"></a>2.自旋锁的定义</h2><p>​    自旋锁的定义：当一个线程尝试去获取某一把锁的时候，如果这个锁此时已经被别人获取(占用)，那么此线程就无法获取到这把锁，该线程将会等待，间隔一段时间后会再次尝试获取。这种采用循环加锁 -&gt; 等待的机制被称为<code>自旋锁(spinlock)</code>。</p><h2 id="3-自旋锁的原理"><a href="#3-自旋锁的原理" class="headerlink" title="3.自旋锁的原理"></a>3.自旋锁的原理</h2><p>​    如果持有锁的线程能在短时间内释放资源，那么那些等待竞争锁的线程就不需要进行内核态和用户态之间的切换进入阻塞状态，只需要等待锁的释放（自旋一小段时间），等到持有锁的线程释放锁之后即可获取到锁，这样做的好处是避免了用户进程和内核态切换的消耗。</p><p>​    自旋锁适用于临界区代码执行时间较短的情况，其他竞争线程只需要等待一小会儿便可以获取到锁，而不用在操作系统的调度下进入阻塞状态然后再切换回来，减少了上下文切换的次数，因此获取自旋锁的进程实际上一直处于用户态，并未进行用户态与内核态的切换。但如果获取锁的线程需要长时间的占用锁，则此时使用自旋锁的效率并不高，大量线程竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起的消耗，其他需要CPU的线程有不能获取到CPU，会造成CPU的浪费。</p><p>​    自旋锁广泛的应用于操作系统内核，是一种轻量级的互斥锁，但是未申请到锁的线程不会被挂起，而是进入忙等待状态。</p><p>​    重点：自旋锁在使用是会自动禁止抢占，这也是为什么不会被操作系统调度的原因，因此如果一个线程一直在自旋等待锁被释放，那么这段时间他还是一直在占用CPU，其他的线程无法抢占他的CPU。</p><h2 id="4-使用自旋锁的注意事项"><a href="#4-使用自旋锁的注意事项" class="headerlink" title="4.使用自旋锁的注意事项"></a>4.使用自旋锁的注意事项</h2><ul><li><p>不应用于长时间加锁</p></li><li><p>被自旋锁保护的临界区不能调用引起睡眠和阻塞的API函数，否则会造成死锁：</p><p>如果线程 A 在持有锁期间进入了休眠状态，那么线程 A 会自动放弃 CPU 使用权。线程 B 开始运行，线程 B 也想要获取锁，但是此时锁被 A 线程持有，而且内核抢占还被禁止了！线程 B 无法被调度出去，那么线程 A 就无法运行，锁也就无法释放，好了，死锁发生了！</p></li><li><p>不能递归申请自旋锁，因为一旦通过递归的方式申请一个你正在持有的锁，那么你就必须“自旋”，等待锁被释放，然而你正处于“自旋”状态，根本没法释放锁。结果就是自己把自己锁死了！</p></li><li><p>在获取锁之前一定要进行之本地中断（当前CPU中断）</p><p>中断中可以使用自旋锁，但是在进入自旋锁的临界区后，又发生了中断，此时新的中断尝试获取锁，但锁正在被原中断持有，现中断无法获取锁，原中断又被打断，无法释放锁，则会造成死锁。</p><p><img src="https://img-blog.csdnimg.cn/20210704161013832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjA5NzEwOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="本地中断导致死锁"></p></li></ul><h2 id="5-具体实现例子待补充……"><a href="#5-具体实现例子待补充……" class="headerlink" title="5.具体实现例子待补充…….."></a>5.具体实现例子待补充……..</h2><h2 id="6-参考链接（纯搬砖）"><a href="#6-参考链接（纯搬砖）" class="headerlink" title="6.参考链接（纯搬砖）"></a>6.参考链接（纯搬砖）</h2><p><a href="http://www.blogjava.net/jinfeng_wang/archive/2016/12/14/432088.html">Java线程 - CAS自旋锁(spin-lock)</a></p><p><a href="https://blog.csdn.net/zhoutianzi12/article/details/103373976"> 什么是自旋锁+自旋锁和互斥锁的区别</a></p><p><a href="https://www.cnblogs.com/cxuanBlog/p/11679883.html">看完你就明白的锁系列之自旋锁</a></p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指32-1</title>
    <link href="/2021/09/24/%E5%89%91%E6%8C%8732-1/"/>
    <url>/2021/09/24/%E5%89%91%E6%8C%8732-1/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer32-I-从上到下打印二叉树"><a href="#剑指-Offer32-I-从上到下打印二叉树" class="headerlink" title="剑指 Offer32-I.从上到下打印二叉树"></a>剑指 Offer32-I.从上到下打印二叉树</h1><hr><p><strong>题目要求：</strong></p><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印.</p><p>例如：给定二叉树[3,9,20,null,null,15,7]</p><div class="hljs code-wrapper"><pre><code>    3   / \  9  20     / \    15 7 </code></pre></div><p>返回：[3,9,20,15,7]</p><p><strong>题目分析:</strong></p><ul><li>对二叉树进行打印实际就是对其进行遍历，根据题目要求，同一层节点按照从左到右的顺序进行遍历，所以应采用层序遍历的方法去遍历。</li><li>层序遍历：借助队列进行实现，要保证读取当前节点后，接下里读取器左右节点，然后是左子节点的左右节点，然后是右子节点的左右节点。起初思路有些错误，想通过递归去进行读取，但是递归一旦深入到一棵子树中，便会继续深入下去，是无法返回保证按层读取的，实际上并不需要递归处理。</li><li>通过队列实现层序遍历：首先将根节点加入队列，然后当队列不为空时进入循环，每一次循环，取出队列头结点，并读取节点数据，然后将其左右节点加入队列（子节点不为空），这样的话，下一次左子节点从队列头取出，同时将其左右子节点加入队列，这样就保证了队列中的数据顺序是按照层序遍历的顺序弹出的。</li><li>注意事项：针对根节点为空，做出针对处理。队列集合对象为Integer,先用Integer数组保存数据，然后转化成int[],返回数组。</li></ul><p><strong>代码实现：</strong></p><div class="hljs code-wrapper"><pre><code>class Solution &#123;ArrayList&lt;Integer&gt; b = new ArrayList&lt;Integer&gt;(1004);Queue&lt;TreeNode&gt; q = new ArrayDeque&lt;&gt;(1004);public int[] levelOrder(TreeNode root) &#123;    if(root == null) &#123;        int[] a = new int[0];        return a;    &#125;    q.add(root);    int i = 0;    TreeNode tem  =  new TreeNode(0) ;    while(!(q.isEmpty()))&#123;        tem = q.remove();        b.add(tem.val);        if(tem.left != null)&#123;            q.add(tem.left);        &#125;        if(tem.right != null)&#123;            q.add(tem.right);        &#125;    &#125;    int[] a = new int[b.size()];    Iterator&lt;Integer&gt; in = b.iterator();    while(in.hasNext())&#123;        a[i++] = in.next();    &#125;    return a;    &#125;&#125;</code></pre></div><p>通过本题主要复习一下使用队列进行层序遍历，以及熟悉Markdown写法。</p>]]></content>
    
    
    <categories>
      
      <category>算法与刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题笔记</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
