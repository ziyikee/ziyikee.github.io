<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>hexo解决图片链接问题</title>
    <link href="/2021/11/06/hexo%E8%A7%A3%E5%86%B3%E5%9B%BE%E7%89%87%E9%93%BE%E6%8E%A5%E9%97%AE%E9%A2%98/"/>
    <url>/2021/11/06/hexo%E8%A7%A3%E5%86%B3%E5%9B%BE%E7%89%87%E9%93%BE%E6%8E%A5%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>在使用 Hexo 撰写博文时，时常需要将图片嵌入 md 文章中，但往往由于图片保存在本地主机，因此在网页中链接图片时，会无法获取本地主机的图片，导致图片不正常显示，在这里我通过使用Hexo插件的方式，保证图片可以正常上传。</p><ol><li><p>首先安装一个图片路径转换的插件：<code>hexo-asset-image</code>，在Hexo主文件夹下使用如下命令：</p><p><code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code></p></li><li><p> 打开_config.yml文件，将<code>post_asset_folder: false</code>修改为<code>true</code></p></li><li><p> 由于该插件本身可能会存在一下Bug，因此将<code>/node_modules/hexo-asset-image/index.js</code>文件的内容更改为如下代码：</p></li></ol>   <figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-keyword">var</span> cheerio = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cheerio&#x27;</span>);<br><br><span class="hljs-comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPosition</span>(<span class="hljs-params">str, m, i</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> str.split(m, i).join(m).length;<br>&#125;<br><br><span class="hljs-keyword">var</span> version = <span class="hljs-built_in">String</span>(hexo.version).split(<span class="hljs-string">&#x27;.&#x27;</span>);<br>hexo.extend.filter.register(<span class="hljs-string">&#x27;after_post_render&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;<br>  <span class="hljs-keyword">var</span> config = hexo.config;<br>  <span class="hljs-keyword">if</span>(config.post_asset_folder)&#123;<br>    <span class="hljs-keyword">var</span> link = data.permalink;<br><span class="hljs-keyword">if</span>(version.length &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">Number</span>(version[<span class="hljs-number">0</span>]) == <span class="hljs-number">3</span>)<br>   <span class="hljs-keyword">var</span> beginPos = getPosition(link, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span><br>   <span class="hljs-keyword">var</span> beginPos = getPosition(link, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-number">3</span>) + <span class="hljs-number">1</span>;<br><span class="hljs-comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span><br><span class="hljs-keyword">var</span> endPos = link.lastIndexOf(<span class="hljs-string">&#x27;/&#x27;</span>) + <span class="hljs-number">1</span>;<br>    link = link.substring(beginPos, endPos);<br><br>    <span class="hljs-keyword">var</span> toprocess = [<span class="hljs-string">&#x27;excerpt&#x27;</span>, <span class="hljs-string">&#x27;more&#x27;</span>, <span class="hljs-string">&#x27;content&#x27;</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; toprocess.length; i++)&#123;<br>      <span class="hljs-keyword">var</span> key = toprocess[i];<br> <br>      <span class="hljs-keyword">var</span> $ = cheerio.load(data[key], &#123;<br>        <span class="hljs-attr">ignoreWhitespace</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">xmlMode</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">lowerCaseTags</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">decodeEntities</span>: <span class="hljs-literal">false</span><br>      &#125;);<br><br>      $(<span class="hljs-string">&#x27;img&#x27;</span>).each(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">if</span> ($(<span class="hljs-built_in">this</span>).attr(<span class="hljs-string">&#x27;src&#x27;</span>))&#123;<br><span class="hljs-comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span><br><span class="hljs-keyword">var</span> src = $(<span class="hljs-built_in">this</span>).attr(<span class="hljs-string">&#x27;src&#x27;</span>).replace(<span class="hljs-string">&#x27;\\&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>);<br><span class="hljs-keyword">if</span>(!<span class="hljs-regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;<br>   !<span class="hljs-regexp">/^\s*\//</span>.test(src)) &#123;<br>  <span class="hljs-comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span><br>  <span class="hljs-comment">// In addition, to support multi-level local directory.</span><br>  <span class="hljs-keyword">var</span> linkArray = link.split(<span class="hljs-string">&#x27;/&#x27;</span>).filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">elem</span>)</span>&#123;<br><span class="hljs-keyword">return</span> elem != <span class="hljs-string">&#x27;&#x27;</span>;<br>  &#125;);<br>  <span class="hljs-keyword">var</span> srcArray = src.split(<span class="hljs-string">&#x27;/&#x27;</span>).filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">elem</span>)</span>&#123;<br><span class="hljs-keyword">return</span> elem != <span class="hljs-string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="hljs-string">&#x27;.&#x27;</span>;<br>  &#125;);<br>  <span class="hljs-keyword">if</span>(srcArray.length &gt; <span class="hljs-number">1</span>)<br>srcArray.shift();<br>  src = srcArray.join(<span class="hljs-string">&#x27;/&#x27;</span>);<br>  $(<span class="hljs-built_in">this</span>).attr(<span class="hljs-string">&#x27;src&#x27;</span>, config.root + link + src);<br>  <span class="hljs-built_in">console</span>.info&amp;&amp;<span class="hljs-built_in">console</span>.info(<span class="hljs-string">&quot;update link as:--&gt;&quot;</span>+config.root + link + src);<br>&#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">console</span>.info&amp;&amp;<span class="hljs-built_in">console</span>.info(<span class="hljs-string">&quot;no src attr, skipped...&quot;</span>);<br><span class="hljs-built_in">console</span>.info&amp;&amp;<span class="hljs-built_in">console</span>.info($(<span class="hljs-built_in">this</span>));<br>&#125;<br>      &#125;);<br>      data[key] = $.html();<br>    &#125;<br>  &#125;<br>&#125;);<br><br><br></code></pre></div></td></tr></table></figure><ol start="4"><li><p>尝试新建一个md文件，插件会自动在_post目录下生成一个与md文件同名的目录，之后向md文件中加入图片时，需要将该图片先放到同名目录下，然后使用图片链接加入图片，实例：</p><ul><li><p><code>hexo -new &quot;hexo解决图片链接问题&quot;</code></p></li><li><p>接下来会看到_post目录下生成了md文件和同名的文件夹，如图：<img src="/2021/11/06/hexo%E8%A7%A3%E5%86%B3%E5%9B%BE%E7%89%87%E9%93%BE%E6%8E%A5%E9%97%AE%E9%A2%98/hexo%E8%A7%A3%E5%86%B3%E5%9B%BE%E7%89%87%E9%93%BE%E6%8E%A5%E9%97%AE%E9%A2%98%5C1.png" srcset="/img/loading.gif" lazyload alt="生成结果"></p></li><li><p>使用规定的图片链接语法便可以链接图片：<code>[生成结果](hexo解决图片链接问题\1.png)</code></p></li></ul><p>参考链接：</p><p>​    <a href="https://blog.csdn.net/xjm850552586/article/details/84101345?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.no_search_link"> hexo引用本地图片无法显示_Ericam_-CSDN博客_hexo 图片</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KING OF HEART</title>
    <link href="/2021/11/06/KING-OF-HEART/"/>
    <url>/2021/11/06/KING-OF-HEART/</url>
    
    <content type="html"><![CDATA[<ul><li>请别再唤我为孤独之人.</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>add domain</title>
    <link href="/2021/10/23/add-domain/"/>
    <url>/2021/10/23/add-domain/</url>
    
    <content type="html"><![CDATA[<h1 id="域名添加"><a href="#域名添加" class="headerlink" title="域名添加"></a>域名添加</h1><p>​    在成功配置好博客并部署在github上之后，我们可以通过<code>xxxxx.github.io</code>的方式去访问博客，但是我想为自己的博客配置一个自己的域名，例如本博客的域名：<a href="www.ziyikee.fun">www.ziyikee.fun</a> ,因此便需要去配置一个自己想要的域名。</p><p>​    首先需要在阿里云或腾讯云等厂商那里去买一个域名，比如我的域名是在阿里云上购买的，在购买域名之后，本来以为需要对域名进行备案才可以使用该域名，然而在进行IPC备案时，对域名备案又需要备案服务码，你必须有自己的服务器才能获得这个备案服务码，因此我一直以为还需要再买一台服务器才行，但是由于我的博客是直接部署在github上的，并不需要自己配置服务器，现在也没有使用服务器的需求（服务器贵的一批），所以我以为配置域名估计要gg了。</p><p>​    但是在知乎查教程发现，将一个域名指向另一个域名其实并不需要备案（π—π），只需要下面几步简单的操作就行了：</p><ul><li><p>首先要购买一个域名，各大厂商都有卖，直接百度搜索即可</p></li><li><p>在域名管理处进行域名解析，添加两条新的记录</p><ol><li>记录类型为：CNAME（将一个域名执行另一个域名），主机记录为：www，记录值为：xxxxx.github.io，保存记录</li><li>记录类型为：CNAME（将一个域名执行另一个域名），主机记录为：@，记录值为：xxxxx.github.io，保存记录</li></ol></li></ul><ul><li><p>之后再本地hexo的source目录下，新建一个CNAME文件，文件内容为你的域名，如ziyikee.fun，保存文件</p></li><li><p>hexo g   hexo d，部署到github之后，便可以通过你的域名直接访问博客。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>博客配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>背包九讲-自译版背包</title>
    <link href="/2021/10/18/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2-%E8%87%AA%E8%AF%91%E7%89%88/"/>
    <url>/2021/10/18/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2-%E8%87%AA%E8%AF%91%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h1 id="背包九讲—自译版"><a href="#背包九讲—自译版" class="headerlink" title="背包九讲—自译版"></a>背包九讲—自译版</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>所谓自译版，就是将某崔大神的背包九讲，用自己理解的意思抄一遍π﹏π（基本结构与内容与原版一致），在最初理解背包问题时，感觉十分难懂，看半天不知所云，因此本文用自己更容易理解的语言复述一遍“背包九讲”，方便日后复习时更方便快捷。</p><h2 id="1-01背包问题"><a href="#1-01背包问题" class="headerlink" title="1.01背包问题"></a>1.01背包问题</h2><p><strong>题目</strong></p><p>有N件物品和一个容量为V的背包。放入第i件物品所占用的容量是c [ i ] ，得到的价值是w [ i ] ,求将哪些物品装入背包可使价值总和最大.（简单来说，就是怎么在容量有限的情况下，使得这个背包里的物品价值总和最大）。</p><p><strong>基本思路</strong></p><p>这是最基础的背包问题，特点是：每件物品仅有一件，可以选择放或不放（这一条件在后面背包问题的延伸中会有所变化，这里是最典型最基础的背包问题。</p><p>用子问题定义状态：即f [ i ] [ j ]表示前  i 件物品恰放入一个容量为  j 的背包可以获得的最大价值（这里原文中使用了“恰”，但实际并不需要正好装满，在初始化可以区分开这两种情况，下文有提及）。则其状态转移方程便是：</p><figure class="highlight inform7"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs inform7">f<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>=max(f<span class="hljs-comment">[i−1]</span><span class="hljs-comment">[j]</span>,f<span class="hljs-comment">[i−1]</span><span class="hljs-comment">[j−c<span class="hljs-comment">[i]</span>]</span>+w<span class="hljs-comment">[i]</span>)<br></code></pre></div></td></tr></table></figure><p>这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生出来的，因此有必要详细解释一下：“将前 i 件物品放入容量为 j 的背包中”这个子问题，若只考虑第 i 件物品的策略（放或不放），那么就可以转化为一个只与前 i - 1 件物品的问题。如果不放第 i 件物品，那么就转化为“前 i- 1 件物品放入容量为 j 的背包中”，其最大价值为 <em>f</em> [i-1] [j]; 如果放第 i 件物品，那么问题就转化为“前 i -1件物品放入剩下的容量为 j - c[j]的背包中”，此时能获取的最大价值就是 <em>f</em> [i-1] [ j - c[ i ]]再加上第 i 件物品获得的价值 w[i]。其伪代码如下：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">F</span>[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>..V ] ← <span class="hljs-number">0</span> //初始值为<span class="hljs-number">0</span>，这与具体问题有关，下面会详细解释<br><span class="hljs-attribute">for</span> i ← <span class="hljs-number">1</span> to N //第<span class="hljs-number">1</span>个装入V，第<span class="hljs-number">2</span>个装入V......<br><span class="hljs-attribute">for</span> v ← Ci to V //第i个装入v，装入v-<span class="hljs-number">1</span>.....<br><span class="hljs-attribute">F</span>[i, v] ← max&#123;F[i − <span class="hljs-number">1</span>, v], F[i − <span class="hljs-number">1</span>, v − Ci] + Wi&#125;<br><br></code></pre></div></td></tr></table></figure><p><strong>优化空间复杂度</strong></p><p>上述方法的时间和空间复杂度均为<em>O</em>（V *N）,其中时间复杂度已经无法继续优化，但空间复杂度可以优化到 <em>O</em>(N)。</p><p>因为每次循环的内部都是：<code>f[i][j]=max(f[i−1][j],f[i−1][j−c[i]]+w[i])</code>，因此在外层循环中，是变量i在已知进行+1的循环，那么如果我们只用<em>f</em> [ j ]用来表示每次循环时，当前循环第 i 次时向容量为 j 的背包中进行选择（针对第 i 个物品放与不放的选择），那么上一次循环（第 i -1次，第 i - 1个物品）计算的结果，到当前循环（第 i 次，第 i 个物品）时，在第二次循环到 j 时，我们的 <em>f</em> [ j ]的值，其实就是 <em>f</em> [ i-1] [ j ]，<em>f</em> [ j - c[i]]的值其实就是上一轮的 <em>f</em> [ i-1] [ j - c[i]]，因此如果我们在第二层循环中使用倒序：j 从V到 c [ i ]，那么我们在计算时，就可以利用上一轮的计算值，将循环语句改为：<code> f[j] = max(f[j], f[j - c[i]] + w[i]);</code>，因为是倒序，所以在未改变前面的值之前，他们保存的是上一轮（第 i - 1轮）的结果，所以核心代码可优化为：</p><figure class="highlight inform7"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs inform7">for (int i = 1; i &lt;= n; i++)<br>    for (int j = V; j &gt;= c<span class="hljs-comment">[i]</span>; j--)<br>        f<span class="hljs-comment">[j]</span> = max(f<span class="hljs-comment">[j]</span>, f<span class="hljs-comment">[j - c<span class="hljs-comment">[i]</span>]</span> + w<span class="hljs-comment">[i]</span>);<br></code></pre></div></td></tr></table></figure><p>因为每次循环都要利用上一次循环运算结果前面的那些值（ j 要用到上一次的 j 和 j - c [i] )，所以要使用倒序来利用上一轮的值，如果使用顺序的话，当前值改变之后，后面的值就无法利用当前值上一轮的结果了，因为已经发生了改变。</p><p><strong>初始化的细节问题</strong></p><p>这里有一个很巧妙的问题，就是在初始化<em>f</em> [ 0 ] [ j ] ( j 从 0 到 V) 或 <em>f</em> [ j ] ( j 从 0 到 V ) 时，是初始化为 0 还是初始化为 负无穷，这两个值其实是针对不同的问题的：</p><ul><li>如果我们要求最终恰好装满背包，那么除了<em>f</em> [ 0 ]以外的数组值，其初始化的值应该设置为负无穷；</li></ul><ul><li>如果我们要求在背包容量的限制下装价值最大就行，并不要求装满，那么初始化的值应该设置为 0；</li></ul><p>造成该差别的原因依然在循环语句中，我们可以仔细分析一下这句：</p><figure class="highlight inform7"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs inform7">f<span class="hljs-comment">[j]</span> = max(f<span class="hljs-comment">[j]</span>, f<span class="hljs-comment">[j - c<span class="hljs-comment">[i]</span>]</span> + w<span class="hljs-comment">[i]</span>);<br></code></pre></div></td></tr></table></figure><p>当我们把值设为负无穷时，在最初，<em>f</em> [ j ]是负无穷，当我们装入第 i 件物品时，如果恰好装满，那么此时 j  - c [ i ] 等于0，这个时候才可以利用 <em>f</em> [0] = 0，再加上w[i]，使得<em>f</em> [ j ]的值被更新为正的，才能保证后续也恰好装满的时候，值为正的。倘若不能恰好装满，我们是没有办法凑出所有 i 的容量加起来等于V，那么在循环过程中 j  - c [ i ] 永远无法等于0，那就算加上了w[ i ]，也是在负无穷上加一个数还是负的，因此只有恰好装满时，最后再能得到正的价值值。</p><p>但如果我们将初始值都设置为 0 时，不管有没有恰好装满，只要可以装进去就行，我们就能在f[j] 和f[j - c[i]]之间选择一个最大的，即在当前容量下，针对 i 件物品所能装的最大价值值，这时是否恰好装满将不再产生影响。</p><p><strong>小结</strong></p><p>01背包问题是最基本的背包问题，它包含了背包问题中设计状态、方程的最基本思想，另外，别的类型的背包问题往往也可以转换成01背包问题求解。故一定要仔细体会上面基本思路的得出方法，状态转移方程的意义，以及最后怎样优化的空间复杂度。</p><p><strong>例题</strong></p><p><a href="https://www.acwing.com/problem/content/2/">AcWing 01背包问题</a><br><a href="https://www.luogu.org/problemnew/show/P2925">Luogu P2925干草出售</a><br><a href="https://www.luogu.org/problemnew/show/P1616">Luogu P1616疯狂的采药</a><br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3466">HDU 3466 Proud Merchants</a></p><h2 id="2-完全背包问题（待补充）"><a href="#2-完全背包问题（待补充）" class="headerlink" title="2.完全背包问题（待补充）"></a>2.完全背包问题（待补充）</h2><h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="https://blog.csdn.net/yandaoqiusheng/article/details/84782655">背包九讲通俗易懂版—我就是抄人家的，写的真好</a></p>]]></content>
    
    
    <categories>
      
      <category>算法与刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>背包问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自旋锁</title>
    <link href="/2021/10/18/%E8%87%AA%E6%97%8B%E9%94%81/"/>
    <url>/2021/10/18/%E8%87%AA%E6%97%8B%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h1><h2 id="1-提出背景："><a href="#1-提出背景：" class="headerlink" title="1.提出背景："></a>1.提出背景：</h2><p>​    由于多处理器环境中，某些资源的有限性，对于多个线程共享的资源进行访问时，需要进行互斥访问，便需要引入锁的概念，只有获取了锁的线程才可以对资源进行访问，由于多线程的核心是CPU的时间分片，所以同一时刻只能有一个线程获取锁。</p><p>​    当锁没有被占用时，尝试获取锁的线程成功获取到锁，之后若有另外的线程尝试获取锁，通常有两种处理方式：</p><p>​        1.没有获取到锁的线程就一直循环等待判断该资源是否已经释放锁，这种锁叫做自旋锁。</p><p>​        2.没有获取到锁的线程将自己阻塞起来，等待重新调度请求，这种锁叫互斥锁。</p><h2 id="2-自旋锁的定义"><a href="#2-自旋锁的定义" class="headerlink" title="2.自旋锁的定义"></a>2.自旋锁的定义</h2><p>​    自旋锁的定义：当一个线程尝试去获取某一把锁的时候，如果这个锁此时已经被别人获取(占用)，那么此线程就无法获取到这把锁，该线程将会等待，间隔一段时间后会再次尝试获取。这种采用循环加锁 -&gt; 等待的机制被称为<code>自旋锁(spinlock)</code>。</p><h2 id="3-自旋锁的原理"><a href="#3-自旋锁的原理" class="headerlink" title="3.自旋锁的原理"></a>3.自旋锁的原理</h2><p>​    如果持有锁的线程能在短时间内释放资源，那么那些等待竞争锁的线程就不需要进行内核态和用户态之间的切换进入阻塞状态，只需要等待锁的释放（自旋一小段时间），等到持有锁的线程释放锁之后即可获取到锁，这样做的好处是避免了用户进程和内核态切换的消耗。</p><p>​    自旋锁适用于临界区代码执行时间较短的情况，其他竞争线程只需要等待一小会儿便可以获取到锁，而不用在操作系统的调度下进入阻塞状态然后再切换回来，减少了上下文切换的次数，因此获取自旋锁的进程实际上一直处于用户态，并未进行用户态与内核态的切换。但如果获取锁的线程需要长时间的占用锁，则此时使用自旋锁的效率并不高，大量线程竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起的消耗，其他需要CPU的线程有不能获取到CPU，会造成CPU的浪费。</p><p>​    自旋锁广泛的应用于操作系统内核，是一种轻量级的互斥锁，但是未申请到锁的线程不会被挂起，而是进入忙等待状态。</p><p>​    重点：自旋锁在使用是会自动禁止抢占，这也是为什么不会被操作系统调度的原因，因此如果一个线程一直在自旋等待锁被释放，那么这段时间他还是一直在占用CPU，其他的线程无法抢占他的CPU。</p><h2 id="4-使用自旋锁的注意事项"><a href="#4-使用自旋锁的注意事项" class="headerlink" title="4.使用自旋锁的注意事项"></a>4.使用自旋锁的注意事项</h2><ul><li><p>不应用于长时间加锁</p></li><li><p>被自旋锁保护的临界区不能调用引起睡眠和阻塞的API函数，否则会造成死锁：</p><p>如果线程 A 在持有锁期间进入了休眠状态，那么线程 A 会自动放弃 CPU 使用权。线程 B 开始运行，线程 B 也想要获取锁，但是此时锁被 A 线程持有，而且内核抢占还被禁止了！线程 B 无法被调度出去，那么线程 A 就无法运行，锁也就无法释放，好了，死锁发生了！</p></li><li><p>不能递归申请自旋锁，因为一旦通过递归的方式申请一个你正在持有的锁，那么你就必须“自旋”，等待锁被释放，然而你正处于“自旋”状态，根本没法释放锁。结果就是自己把自己锁死了！</p></li><li><p>在获取锁之前一定要进行之本地中断（当前CPU中断）</p><p>中断中可以使用自旋锁，但是在进入自旋锁的临界区后，又发生了中断，此时新的中断尝试获取锁，但锁正在被原中断持有，现中断无法获取锁，原中断又被打断，无法释放锁，则会造成死锁。</p><p><img src="https://img-blog.csdnimg.cn/20210704161013832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjA5NzEwOA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="本地中断导致死锁"></p></li></ul><h2 id="5-具体实现例子待补充……"><a href="#5-具体实现例子待补充……" class="headerlink" title="5.具体实现例子待补充…….."></a>5.具体实现例子待补充……..</h2><h2 id="6-参考链接（纯搬砖）"><a href="#6-参考链接（纯搬砖）" class="headerlink" title="6.参考链接（纯搬砖）"></a>6.参考链接（纯搬砖）</h2><p><a href="http://www.blogjava.net/jinfeng_wang/archive/2016/12/14/432088.html">Java线程 - CAS自旋锁(spin-lock)</a></p><p><a href="https://blog.csdn.net/zhoutianzi12/article/details/103373976"> 什么是自旋锁+自旋锁和互斥锁的区别</a></p><p><a href="https://www.cnblogs.com/cxuanBlog/p/11679883.html">看完你就明白的锁系列之自旋锁</a></p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指32-1</title>
    <link href="/2021/09/24/%E5%89%91%E6%8C%8732-1/"/>
    <url>/2021/09/24/%E5%89%91%E6%8C%8732-1/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer32-I-从上到下打印二叉树"><a href="#剑指-Offer32-I-从上到下打印二叉树" class="headerlink" title="剑指 Offer32-I.从上到下打印二叉树"></a>剑指 Offer32-I.从上到下打印二叉树</h1><hr><p><strong>题目要求：</strong></p><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印.</p><p>例如：给定二叉树[3,9,20,null,null,15,7]</p><div class="hljs code-wrapper"><pre><code>    3   / \  9  20     / \    15 7 </code></pre></div><p>返回：[3,9,20,15,7]</p><p><strong>题目分析:</strong></p><ul><li>对二叉树进行打印实际就是对其进行遍历，根据题目要求，同一层节点按照从左到右的顺序进行遍历，所以应采用层序遍历的方法去遍历。</li><li>层序遍历：借助队列进行实现，要保证读取当前节点后，接下里读取器左右节点，然后是左子节点的左右节点，然后是右子节点的左右节点。起初思路有些错误，想通过递归去进行读取，但是递归一旦深入到一棵子树中，便会继续深入下去，是无法返回保证按层读取的，实际上并不需要递归处理。</li><li>通过队列实现层序遍历：首先将根节点加入队列，然后当队列不为空时进入循环，每一次循环，取出队列头结点，并读取节点数据，然后将其左右节点加入队列（子节点不为空），这样的话，下一次左子节点从队列头取出，同时将其左右子节点加入队列，这样就保证了队列中的数据顺序是按照层序遍历的顺序弹出的。</li><li>注意事项：针对根节点为空，做出针对处理。队列集合对象为Integer,先用Integer数组保存数据，然后转化成int[],返回数组。</li></ul><p><strong>代码实现：</strong></p><div class="hljs code-wrapper"><pre><code>class Solution &#123;ArrayList&lt;Integer&gt; b = new ArrayList&lt;Integer&gt;(1004);Queue&lt;TreeNode&gt; q = new ArrayDeque&lt;&gt;(1004);public int[] levelOrder(TreeNode root) &#123;    if(root == null) &#123;        int[] a = new int[0];        return a;    &#125;    q.add(root);    int i = 0;    TreeNode tem  =  new TreeNode(0) ;    while(!(q.isEmpty()))&#123;        tem = q.remove();        b.add(tem.val);        if(tem.left != null)&#123;            q.add(tem.left);        &#125;        if(tem.right != null)&#123;            q.add(tem.right);        &#125;    &#125;    int[] a = new int[b.size()];    Iterator&lt;Integer&gt; in = b.iterator();    while(in.hasNext())&#123;        a[i++] = in.next();    &#125;    return a;    &#125;&#125;</code></pre></div><p>通过本题主要复习一下使用队列进行层序遍历，以及熟悉Markdown写法。</p>]]></content>
    
    
    <categories>
      
      <category>算法与刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题笔记</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/09/19/hello-world/"/>
    <url>/2021/09/19/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h1 id="本站更新记录"><a href="#本站更新记录" class="headerlink" title="本站更新记录"></a>本站更新记录</h1><h2 id="2021-10-19"><a href="#2021-10-19" class="headerlink" title="2021.10.19"></a>2021.10.19</h2><ul><li>完善个人信息</li><li>增加了网页访问量统计</li><li>发现首页的文章是可以配图的（原来不是主题不好，是我太菜不会用π_π）</li><li>不会加评论功能。。。</li><li>woc，两个小时候评论功能成功了，其实设置好简单。。</li></ul><h2 id="2021-10-20"><a href="#2021-10-20" class="headerlink" title="2021.10.20"></a>2021.10.20</h2><ul><li>增加了运行时间</li><li>增加了转载版权标识（链接内容有问题，未解决）</li><li>页面底部内容修改</li><li>字体修改：参考：<a href="https://bestzuo.cn/posts/notoserifsc.html">博客网站字体设置：思源宋体 (bestzuo.cn)</a>，<a href="https://www.erenship.com/posts/40222.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93">Hexo’s Fluid 主题私人定制（持续更新） - Eren の 宇宙船 (erenship.com)</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
