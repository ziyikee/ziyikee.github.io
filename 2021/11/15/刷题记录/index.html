

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@500&display=swap" rel="stylesheet">
  <!-- <link href="https://fonts.googleapis.com.css2?family=Noto+Serif+SC:wght@400;500;600;700;900&display=swap" rel = "stylesheet"> -->
  <link rel="apple-touch-icon" sizes="76x76" href="https://cdn.jsdelivr.net/gh/ziyikee/blog_img/blog_img/202201131435626.png">
  <link rel="icon" href="https://cdn.jsdelivr.net/gh/ziyikee/blog_img/blog_img/202201131435626.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="每日刷题记录">
  <meta name="author" content="ziyikee">
  <meta name="keywords" content="java">
  <meta name="description" content="每日刷题记录">
<meta property="og:type" content="article">
<meta property="og:title" content="刷题记录">
<meta property="og:url" content="https://ziyikee.fun/2021/11/15/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/index.html">
<meta property="og:site_name" content="Blog by ziyikee">
<meta property="og:description" content="每日刷题记录">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ziyikee/blog_img/blog_img/202201162233400.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ziyikee/blog_img/blog_img/202201131353202.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ziyikee/blog_img/blog_img/202201131353688.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ziyikee/blog_img/blog_img/202201131353100.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ziyikee/blog_img/blog_img/202201131354231.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ziyikee/blog_img/blog_img/202201131354117.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ziyikee/blog_img/blog_img/202201131354541.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ziyikee/blog_img/blog_img/202201131354098.png">
<meta property="article:published_time" content="2021-11-15T10:52:02.000Z">
<meta property="article:modified_time" content="2022-01-28T04:21:07.433Z">
<meta property="article:author" content="ziyikee">
<meta property="article:tag" content="刷题记录">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/ziyikee/blog_img/blog_img/202201162233400.png">
  
  <title>刷题记录 - Blog by ziyikee</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/bynotes/texiao/source/css/gundongtiao.css# 滚动条颜色.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"ziyikee.fun","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"<-","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":true,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"41fc030db57d5570dd22f78997dc4a7e","google":"G-TKFRYZGQQM","gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"Yax4VGrJCLUimOwWC0IUwUBl-gzGzoHsz","app_key":"mkp5UxNkruz1T9ByVFewLjOi","server_url":"https://yax4vgrj.lc-cn-n1-shared.com","path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 80vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Blog by ziyikee.</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://cdn.jsdelivr.net/gh/ziyikee/blog_img/blog_img/202201131422840.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="刷题记录">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      ziyikee
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-11-15 18:52" pubdate>
        2021年11月15日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      51k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      159 分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
            <div class="scroll-down-bar">
              <i class="iconfont icon-arrowdown"></i>
            </div>
          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">刷题记录</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2022年1月28日 中午
                
              </p>
            
            <div class="markdown-body">
              <div class="note note-success">
            <p>为了避免将来连笔试都过不了，zyk决定每天刷题！</p>
          </div>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不知不觉，已经好久没有刷题了，算法又太重要了，好焦虑。</p>
<p>学校的OJ只能用c++，但是我准备的又是java，长期不写java，连基本的API都快忘记了，所以写这个帖子，每天刷几道题吧，数量不限，看时间是否充足。</p>
<p>当前目标：先把剑指OFFER刷一遍。</p>
<h2 id="2022-1-27"><a href="#2022-1-27" class="headerlink" title="2022-1-27"></a>2022-1-27</h2><h3 id="lc-42-接雨水"><a href="#lc-42-接雨水" class="headerlink" title="lc-42.接雨水"></a>lc-42.接雨水</h3><p>单调栈方法，如果当前高度大于栈顶高度，则说明遇到了槽，将槽弹出，为底的高度，此时如果栈不为空，则再取栈顶，其值与当前值中较小的一个为横向槽的高度，计算横向槽的大小。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;<br>        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack();<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        stack.push(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>  i = <span class="hljs-number">1</span>;i&lt;height.length;i++)&#123;<br>            <span class="hljs-keyword">while</span>(!stack.isEmpty()&amp;&amp;height[i]&gt;height[stack.peek()])&#123;<br>                <span class="hljs-keyword">int</span> mid = stack.pop();<br>                <span class="hljs-keyword">if</span>(!stack.isEmpty())&#123;<br>                    <span class="hljs-keyword">int</span> h = Math.min(height[stack.peek()],height[i]) - height[mid];<span class="hljs-comment">//gao</span><br>                    <span class="hljs-keyword">int</span> w = i - stack.peek()-<span class="hljs-number">1</span>;<span class="hljs-comment">//di</span><br>                    sum = sum + h * w;<br>                &#125;<br>            &#125;<br>            stack.push(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>动态规划，这里按照列去计算，获取每一列的左边的最大高度与右边的最大高度，以当前列的高度为底，宽为1，高度为两边最大高度较小值减去底的高度。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = height.length;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span>[] leftMax = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<span class="hljs-comment">//左边最大高度获取</span><br>        leftMax[<span class="hljs-number">0</span>] = height[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            leftMax[i] = Math.max(leftMax[i - <span class="hljs-number">1</span>], height[i]);<br>        &#125;<br><br>        <span class="hljs-keyword">int</span>[] rightMax = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<span class="hljs-comment">//右边最大高度获取</span><br>        rightMax[n - <span class="hljs-number">1</span>] = height[n - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            rightMax[i] = Math.max(rightMax[i + <span class="hljs-number">1</span>], height[i]);<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            ans += Math.min(leftMax[i], rightMax[i]) - height[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="lc-347-前K个高频元素"><a href="#lc-347-前K个高频元素" class="headerlink" title="lc-347.前K个高频元素"></a>lc-347.前K个高频元素</h3><p>优先队列，做了太多遍了，这里主要学习一下Map的相关操作，以及进一步熟悉比较器Comparator的使用。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] topKFrequent(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;<br>        <br>        Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;Integer,Integer&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : nums)&#123;<br>            map.put(i,map.getOrDefault(i,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>        &#125;<br>        PriorityQueue&lt;Map.Entry&lt;Integer,Integer&gt;&gt; queue = <span class="hljs-keyword">new</span> PriorityQueue(<span class="hljs-keyword">new</span> Comparator()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Object o1, Object o2)</span> </span>&#123;<span class="hljs-comment">//注意这里必须是Object</span><br>                Map.Entry&lt;Integer,Integer&gt; m1 = (Map.Entry&lt;Integer,Integer&gt;)o1;<br>                Map.Entry&lt;Integer,Integer&gt; m2 = (Map.Entry&lt;Integer,Integer&gt;)o2;<br>                <span class="hljs-keyword">return</span> m2.getValue()-m1.getValue();<br>            &#125;<br>        &#125;<br>        );<br>       Set&lt;Map.Entry&lt;Integer,Integer&gt;&gt; set = map.entrySet();<br>       <span class="hljs-keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; e : set)&#123;<br>           queue.add(e);<br>       &#125;<br>       <span class="hljs-keyword">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k];<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>           ans[i] = queue.poll().getKey();<br>       &#125;<br>       <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="lc-239-滑动窗口最大值"><a href="#lc-239-滑动窗口最大值" class="headerlink" title="lc-239.滑动窗口最大值"></a>lc-239.滑动窗口最大值</h3><p>hard，使用双端队列实现，LinkedList可以提供栈，队列的很多功能！！</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] maxSlidingWindow(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;<br>        LinkedList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> LinkedList();<span class="hljs-comment">//双向队列，可以同时在队首和对尾插入和删除</span><br>        <span class="hljs-keyword">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length - k +<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>            <span class="hljs-keyword">while</span>(!list.isEmpty()&amp;&amp;nums[list.getLast()]&lt;nums[i])&#123;<br>                list.pollLast();<br>            &#125;<br>            list.addLast(i);<br>        &#125;<br>        ans[<span class="hljs-number">0</span>] = nums[list.getFirst()];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = k;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-keyword">while</span>(!list.isEmpty()&amp;&amp;nums[list.getLast()]&lt;nums[i])&#123;<br>                list.pollLast();<br>            &#125;<span class="hljs-comment">//每次push的时候，都向队尾加，如果队尾的值小于需要添加的值，就移除，毕竟每次取的都是最大值，小的值直接除掉，这样队首的值肯定是最大的</span><br>            list.addLast(i);<br>            <span class="hljs-keyword">while</span>(list.getFirst()&lt;i-k+<span class="hljs-number">1</span>)&#123;<br>                list.pollFirst();<span class="hljs-comment">//最大值从队首取，并且需要保证在窗口范围内，不在就移除</span><br>            &#125;<br>            ans[i-k+<span class="hljs-number">1</span>] = nums[list.getFirst()];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>



<h2 id="2022-1-24"><a href="#2022-1-24" class="headerlink" title="2022-1-24"></a>2022-1-24</h2><h3 id="lc-150-逆波兰表达式求值"><a href="#lc-150-逆波兰表达式求值" class="headerlink" title="lc-150.逆波兰表达式求值"></a>lc-150.逆波兰表达式求值</h3><p>easy，用栈即可</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">evalRPN</span><span class="hljs-params">(String[] tokens)</span> </span>&#123;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>        <span class="hljs-keyword">int</span> n = tokens.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            String token = tokens[i];<br>            <span class="hljs-keyword">if</span> (isNumber(token)) &#123;<br>                stack.push(Integer.parseInt(token));<span class="hljs-comment">//String转为Integer</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">int</span> num2 = stack.pop();<br>                <span class="hljs-keyword">int</span> num1 = stack.pop();<br>                <span class="hljs-keyword">switch</span> (token) &#123;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:<br>                        stack.push(num1 + num2);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:<br>                        stack.push(num1 - num2);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>:<br>                        stack.push(num1 * num2);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:<br>                        stack.push(num1 / num2);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">default</span>:<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.pop();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isNumber</span><span class="hljs-params">(String token)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> !(<span class="hljs-string">&quot;+&quot;</span>.equals(token) || <span class="hljs-string">&quot;-&quot;</span>.equals(token) || <span class="hljs-string">&quot;*&quot;</span>.equals(token) || <span class="hljs-string">&quot;/&quot;</span>.equals(token));<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="lc-20-有效的括号"><a href="#lc-20-有效的括号" class="headerlink" title="lc-20.有效的括号"></a>lc-20.有效的括号</h3><p>easy</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">char</span>[] c = s.toCharArray();<br>        Stack&lt;Character&gt; st = <span class="hljs-keyword">new</span> Stack();<br>        <span class="hljs-keyword">int</span> len = c.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            <span class="hljs-keyword">if</span>(c[i]==<span class="hljs-string">&#x27;&#123;&#x27;</span>) &#123;<br>                st.push(<span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c[i]==<span class="hljs-string">&#x27;[&#x27;</span>)&#123;<br>                st.push(<span class="hljs-string">&#x27;]&#x27;</span>);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c[i]==<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                st.push(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(st.isEmpty()||st.peek()!=c[i])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                st.pop();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> st.isEmpty();<br><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="lc-232-用栈实现队列"><a href="#lc-232-用栈实现队列" class="headerlink" title="lc-232.用栈实现队列"></a>lc-232.用栈实现队列</h3><p>easy</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span> </span>&#123;<br>    Stack sin;<br>    Stack sout;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyQueue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.sin = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();<br>        <span class="hljs-keyword">this</span>.sout = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        sin.push(x);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(sout.isEmpty())&#123;<br>            <span class="hljs-keyword">while</span>(!sin.isEmpty())&#123;<br>                sout.push(sin.pop());<br>            &#125;<br>        &#125;<br>        Integer a = (Integer)sout.pop();<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>         <span class="hljs-keyword">if</span>(sout.isEmpty())&#123;<br>            <span class="hljs-keyword">while</span>(!sin.isEmpty())&#123;<br>                sout.push(sin.pop());<br>            &#125;<br>        &#125;<br>        Integer a = (Integer)sout.peek();<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> sin.isEmpty()&amp;&amp;sout.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="lc-459-重复的字符串"><a href="#lc-459-重复的字符串" class="headerlink" title="lc-459.重复的字符串"></a>lc-459.重复的字符串</h3><p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成，给定的字符只含有小写英文字符，并且长度不超过10000。</p>
<p>解题思路：求该字符串的前缀表，如果<code>len % (len - next[len-1]) == 0</code>，则说明可以由重复的子字符串构成。数组长度减去最长相等前后缀的长度相当于第一个重复子字符串的长度，也就是一个重复周期的长度，如果这个周期可以被整除，则说明整个数组就是这个周期的循环。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] next;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(String s)</span></span>&#123;<br>        <span class="hljs-keyword">char</span>[] c = s.toCharArray();<br>        <span class="hljs-keyword">int</span> len = c.length;<br>        next = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];<br>        next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;len;i++)&#123;<br>            <span class="hljs-keyword">while</span>(j&gt;<span class="hljs-number">0</span>&amp;&amp;c[i] != c[j])&#123;<br>                j = next[j-<span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(c[i]==c[j])&#123;<br>                j++;<br>            &#125;<br>            next[i] = j;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">repeatedSubstringPattern</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s==<span class="hljs-keyword">null</span>||s.length()==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        getNext(s);<br>        <span class="hljs-keyword">int</span> len = s.length();<br>        <span class="hljs-keyword">if</span>(next[len-<span class="hljs-number">1</span>]!=<span class="hljs-number">0</span>&amp;&amp;len%(len-next[len-<span class="hljs-number">1</span>])==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="2022-1-20"><a href="#2022-1-20" class="headerlink" title="2022-1-20"></a>2022-1-20</h2><h3 id="lc-344-反转字符串"><a href="#lc-344-反转字符串" class="headerlink" title="lc-344.反转字符串"></a>lc-344.反转字符串</h3><p>easy，双指针。</p>
<h3 id="lc-541-反转字符串2"><a href="#lc-541-反转字符串2" class="headerlink" title="lc-541.反转字符串2"></a>lc-541.反转字符串2</h3><p>easy，双指针</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverseStr</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = s.length();<br>        <span class="hljs-keyword">char</span>[] arr = s.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i += <span class="hljs-number">2</span> * k) &#123;<br>            reverse(arr, i, Math.min(i + k, n) - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(arr);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">char</span> temp = arr[left];<br>            arr[left] = arr[right];<br>            arr[right] = temp;<br>            left++;<br>            right--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="lc-151-翻转字符串里的单词"><a href="#lc-151-翻转字符串里的单词" class="headerlink" title="lc-151.翻转字符串里的单词"></a>lc-151.翻转字符串里的单词</h3><p>mid，不难就是麻烦😓😖</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverseWords</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        StringBuilder sb = trimSpaces(s);<br><br>        <span class="hljs-comment">// 翻转字符串</span><br>        reverse(sb, <span class="hljs-number">0</span>, sb.length() - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 翻转每个单词</span><br>        reverseEachWord(sb);<br><br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title">trimSpaces</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = s.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 去掉字符串开头的空白字符</span><br>        <span class="hljs-keyword">while</span> (left &lt;= right &amp;&amp; s.charAt(left) == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            ++left;<br>        &#125;<br><br>        <span class="hljs-comment">// 去掉字符串末尾的空白字符</span><br>        <span class="hljs-keyword">while</span> (left &lt;= right &amp;&amp; s.charAt(right) == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            --right;<br>        &#125;<br><br>        <span class="hljs-comment">// 将字符串间多余的空白字符去除</span><br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-keyword">char</span> c = s.charAt(left);<br><br>            <span class="hljs-keyword">if</span> (c != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                sb.append(c);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sb.charAt(sb.length() - <span class="hljs-number">1</span>) != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                sb.append(c);<br>            &#125;<br><br>            ++left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(StringBuilder sb, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">char</span> tmp = sb.charAt(left);<br>            sb.setCharAt(left++, sb.charAt(right));<br>            sb.setCharAt(right--, tmp);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverseEachWord</span><span class="hljs-params">(StringBuilder sb)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = sb.length();<br>        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (start &lt; n) &#123;<br>            <span class="hljs-comment">// 循环至单词的末尾</span><br>            <span class="hljs-keyword">while</span> (end &lt; n &amp;&amp; sb.charAt(end) != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                ++end;<br>            &#125;<br>            <span class="hljs-comment">// 翻转单词</span><br>            reverse(sb, start, end - <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 更新start，去找下一个单词</span><br>            start = end + <span class="hljs-number">1</span>;<br>            ++end;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="2022-1-19"><a href="#2022-1-19" class="headerlink" title="2022-1-19"></a>2022-1-19</h2><h3 id="lc-15-三数相加"><a href="#lc-15-三数相加" class="headerlink" title="lc-15.三数相加"></a>lc-15.三数相加</h3><p>mid，双指针法，先排序，从i开始，使用left和right两个指针去寻找i之后可能的情况，需要去重，需要考虑的很多情况。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        ArrayList&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt; ();<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;nums.length - <span class="hljs-number">2</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">break</span> ; <br>            &#125;<br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i-<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//去重，往前判断去重，不要往后判断</span><br>            &#125;<br>            <span class="hljs-keyword">int</span> left = i+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(right&gt;left)&#123;<br>                <span class="hljs-keyword">int</span> tem = nums[i] + nums[left] + nums[right];<br>                <span class="hljs-keyword">if</span>(tem == <span class="hljs-number">0</span>)&#123;<br>                    ArrayList&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> ArrayList();<br>                    temp.add(nums[i]);<br>                    temp.add(nums[left]);<br>                    temp.add(nums[right]);<br>                    ans.add(temp);<br>                    <span class="hljs-keyword">while</span>(right&gt;left&amp;&amp;nums[right]==nums[right-<span class="hljs-number">1</span>])&#123;<br>                        right--;<span class="hljs-comment">//去重 [-2,0,0,2,2]</span><br>                    &#125;<br>                    <span class="hljs-keyword">while</span>(right&gt;left&amp;&amp;nums[left]==nums[left+<span class="hljs-number">1</span>])&#123;<br>                        left++;<span class="hljs-comment">//去重 [-2,0,0,2,2]</span><br>                    &#125;<br>                    right--;<br>                    left++;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tem&lt;<span class="hljs-number">0</span>)&#123;<br>                    left++;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tem&gt;<span class="hljs-number">0</span>)&#123;<br>                    right--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="lc-18-四数之和"><a href="#lc-18-四数之和" class="headerlink" title="lc-18.四数之和"></a>lc-18.四数之和</h3><p>mid，在三数之和的基础上，加一层循环</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>        ArrayList&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt; ();<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;a&lt;nums.length;a++)&#123;<br>            <span class="hljs-keyword">if</span>(a&gt;<span class="hljs-number">0</span>&amp;&amp;nums[a]==nums[a-<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> b = a+<span class="hljs-number">1</span>;b&lt;nums.length;b++)&#123;<br>                <span class="hljs-keyword">if</span>(b&gt;a+<span class="hljs-number">1</span>&amp;&amp;nums[b]==nums[b-<span class="hljs-number">1</span>])&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">int</span> left = b+<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">int</span> right = nums.length-<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span>(right&gt;left)&#123;<br>                    <span class="hljs-keyword">int</span> tem = nums[a] + nums[b] + nums[left] +nums[right];<br>                    <span class="hljs-keyword">if</span>(tem==target)&#123;<br>                        ArrayList&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>                        temp.add(nums[a]);<br>                        temp.add(nums[b]);<br>                        temp.add(nums[left]);<br>                        temp.add(nums[right]);<br>                        ans.add(temp);<br>                        <span class="hljs-keyword">while</span>(right&gt;left&amp;&amp;nums[right]==nums[right-<span class="hljs-number">1</span>])&#123;<br>                            right--;<br>                        &#125;<br>                        <span class="hljs-keyword">while</span>(right&gt;left&amp;&amp;nums[left]==nums[left+<span class="hljs-number">1</span>])&#123;<br>                            left++;<br>                        &#125;<br>                        right--;<br>                        left++;<br>                    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tem &gt; target)&#123;<br>                        right--;<br>                    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tem &lt;target)&#123;<br>                        left++;<br>                    &#125;<br>                &#125;<br><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="lc-454-四数相加2"><a href="#lc-454-四数相加2" class="headerlink" title="lc-454.四数相加2"></a>lc-454.四数相加2</h3><p>mid，四个数组分成两组，然后使用哈希处理</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fourSumCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2, <span class="hljs-keyword">int</span>[] nums3, <span class="hljs-keyword">int</span>[] nums4)</span> </span>&#123;<br>        HashMap&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> a : nums1)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> b : nums2)&#123;<br>                map.put(a+b, map.getOrDefault(a+b, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c : nums3)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> d : nums4)&#123;<br>                <span class="hljs-keyword">if</span>(map.containsKey(<span class="hljs-number">0</span>-c-d))&#123;<br>                    count += map.get(<span class="hljs-number">0</span>-c-d);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="lc-349-两个数组的交集"><a href="#lc-349-两个数组的交集" class="headerlink" title="lc-349.两个数组的交集"></a>lc-349.两个数组的交集</h3><p>easy,重新熟悉一下迭代器<code>iterator</code>的用法</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] intersection(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2) &#123;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> HashSet();<br>        Set&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> HashSet();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;nums1.length;i++)&#123;<br>            set.add(nums1[i]);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;nums2.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(set.contains(nums2[i]))&#123;<br>                ans.add(nums2[i]);<br>            &#125;<br>        &#125;<br>        Iterator&lt;Integer&gt; in = ans.iterator();<br>        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[ans.size()];<br>        <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(in.hasNext())&#123;<br>            res[x++] = in.next(); <br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="lc-242-有效的字母异位词"><a href="#lc-242-有效的字母异位词" class="headerlink" title="lc-242.有效的字母异位词"></a>lc-242.有效的字母异位词</h3><p>easy，排序，然后一一比较，或者使用哈希表，记录每个字母出现的次数，遍历s，次数++，遍历t，次数–，最后看所有字母的次数是否为0</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(String s, String t)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.length()!=t.length()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">char</span>[] ss = s.toCharArray();<br>        <span class="hljs-keyword">char</span>[] tt = t.toCharArray();<br>        Arrays.sort(ss);<br>        Arrays.sort(tt);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;ss.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(ss[i]!=tt[i])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>



<h3 id="lc-669-修建二叉搜索树"><a href="#lc-669-修建二叉搜索树" class="headerlink" title="lc-669.修建二叉搜索树"></a>lc-669.修建二叉搜索树</h3><p>easy</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">trimBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span>(root.val&lt;low)&#123;<br>            <span class="hljs-keyword">return</span> trimBST(root.right,low,high);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root.val&gt;high)&#123;<br>            <span class="hljs-keyword">return</span> trimBST(root.left,low,high);<br>        &#125;<br>        root.left = trimBST(root.left,low,high);<br>        root.right = trimBST(root.right,low,high);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="lc-108-构建平衡二叉搜索树"><a href="#lc-108-构建平衡二叉搜索树" class="headerlink" title="lc-108.构建平衡二叉搜索树"></a>lc-108.构建平衡二叉搜索树</h3><p>easy</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] numss;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = nums.length;<br>        numss = nums;<br>        <span class="hljs-keyword">return</span> build(<span class="hljs-number">0</span>,len-<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(left&gt;right) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">int</span> mid = left + (right-left)/<span class="hljs-number">2</span> ;<br>        TreeNode cur = <span class="hljs-keyword">new</span> TreeNode(numss[mid]);<br>        cur.left = build(left,mid-<span class="hljs-number">1</span>);<br>        cur.right = build(mid+<span class="hljs-number">1</span>,right);<br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="2022-1-16"><a href="#2022-1-16" class="headerlink" title="2022-1-16"></a>2022-1-16</h2><h3 id="lc-14-最长公共前缀"><a href="#lc-14-最长公共前缀" class="headerlink" title="lc-14.最长公共前缀"></a>lc-14.最长公共前缀</h3><p>easy，暴力</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(String[] strs)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> count = strs.length;<br>        <span class="hljs-keyword">if</span>(count==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>            <span class="hljs-keyword">int</span> flag = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;count;i++)&#123;<br>                <span class="hljs-keyword">if</span>(len&lt;strs[i-<span class="hljs-number">1</span>].length()&amp;&amp;len&lt;strs[i].length())&#123;<br>                    <span class="hljs-keyword">if</span>(strs[i].charAt(len)==strs[i-<span class="hljs-number">1</span>].charAt(len))&#123;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        flag = <span class="hljs-number">0</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    flag = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">break</span> ;<br>            &#125;<br>            len++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>].substring(<span class="hljs-number">0</span>,len);<br><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="lc-382-链表的随机节点"><a href="#lc-382-链表的随机节点" class="headerlink" title="lc-382.链表的随机节点"></a>lc-382.链表的随机节点</h3><p>离谱题，人家用了一种蓄水池算法，只能说我见识浅陋了😅</p>
<p><img src="https://cdn.jsdelivr.net/gh/ziyikee/blog_img/blog_img/202201162233400.png" srcset="/img/loading.gif" lazyload alt="image-20220116223302317"></p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    ListNode myhead;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Solution</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        myhead = head;<br>    &#125;    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getRandom</span><span class="hljs-params">()</span> </span>&#123;<br>        ListNode tem = myhead;<br>        Random random = <span class="hljs-keyword">new</span> Random();<br>        <span class="hljs-keyword">int</span> ans = tem.val;<br>        <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(tem!=<span class="hljs-keyword">null</span>)&#123;<br>            len++;<br>            <span class="hljs-keyword">if</span>(random.nextInt(len)==<span class="hljs-number">0</span>)&#123;<br>                ans = tem.val;<br>            &#125;<br>            tem = tem.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="lc-450-删除二叉搜索数中的节点"><a href="#lc-450-删除二叉搜索数中的节点" class="headerlink" title="lc-450.删除二叉搜索数中的节点"></a>lc-450.删除二叉搜索数中的节点</h3><p>mid，最复杂的情况是被删除的节点的左右子树都存在，此时只需要将左子树接到右子树的最左边的节点的左边，返回右子树即可。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">if</span>(root.val==key)&#123;<br>            <span class="hljs-keyword">if</span>(root.left==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> root.right;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.right==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> root.left;<br>            <span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">//删除的节点的左右子树均不为空</span><br>            <span class="hljs-comment">//把左子树接到右子树的最左边的节点上，返回右子树即可</span><br>                TreeNode cur = root.right;<br>                <span class="hljs-keyword">while</span>(cur.left!=<span class="hljs-keyword">null</span>)&#123;<br>                    cur = cur.left;<br>                &#125;<br>                cur.left = root.left;<br>                <span class="hljs-keyword">return</span> root.right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(key&gt;root.val) &#123;<br>            root.right = deleteNode(root.right,key);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            root.left = deleteNode(root.left,key);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="lc-701-二叉搜索树中的插入操作"><a href="#lc-701-二叉搜索树中的插入操作" class="headerlink" title="lc-701.二叉搜索树中的插入操作"></a>lc-701.二叉搜索树中的插入操作</h3><p>mid，只考虑最简单的插入方式，只插入到左子树为空或右子树为空且值满足条件的地方，不在中间插入，太麻烦。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) &#123;<br>            root = <span class="hljs-keyword">new</span> TreeNode(val);<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root.val &gt; val)&#123;<br>            <span class="hljs-keyword">if</span>(root.left!=<span class="hljs-keyword">null</span>)&#123;<br>                root.left = insertIntoBST(root.left,val);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                TreeNode tem = <span class="hljs-keyword">new</span> TreeNode(val);<br>                tem.left = <span class="hljs-keyword">null</span>;<br>                tem.right=<span class="hljs-keyword">null</span>;<br>                root.left = tem;<br>                <span class="hljs-keyword">return</span> root;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>             <span class="hljs-keyword">if</span>(root.right!=<span class="hljs-keyword">null</span>)&#123;<br>                root.right = insertIntoBST(root.right,val);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                TreeNode tem = <span class="hljs-keyword">new</span> TreeNode(val);<br>                tem.left = <span class="hljs-keyword">null</span>;<br>                tem.right=<span class="hljs-keyword">null</span>;<br>                root.right = tem;<br>                <span class="hljs-keyword">return</span> root;<br>            &#125;       <br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="lc-236-二叉树的最近公共祖先"><a href="#lc-236-二叉树的最近公共祖先" class="headerlink" title="lc-236.二叉树的最近公共祖先"></a>lc-236.二叉树的最近公共祖先</h3><p>后序遍历，自底向上回溯。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==p||root==q||root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> root;<br>        TreeNode left = lowestCommonAncestor(root.left,p,q);<br>        TreeNode right = lowestCommonAncestor(root.right,p,q);<br>        <span class="hljs-keyword">if</span>(left==<span class="hljs-keyword">null</span>&amp;&amp;right!=<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> right;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left!=<span class="hljs-keyword">null</span>&amp;&amp;right==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> left;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left!=<span class="hljs-keyword">null</span>&amp;&amp;right!=<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="lc-235-二叉搜索树的最近公共祖先"><a href="#lc-235-二叉搜索树的最近公共祖先" class="headerlink" title="lc-235.二叉搜索树的最近公共祖先"></a>lc-235.二叉搜索树的最近公共祖先</h3><p>easy</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==p||root==q ||root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">if</span>(root.val&gt;p.val&amp;&amp;root.val&gt;q.val) <span class="hljs-keyword">return</span> lowestCommonAncestor(root.left,p,q);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.val&lt;p.val&amp;&amp;root.val&lt;q.val) <span class="hljs-keyword">return</span> lowestCommonAncestor(root.right,p,q);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.val&gt;p.val&amp;&amp;root.val&lt;q.val) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.val&lt;p.val&amp;&amp;root.val&gt;q.val) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>



<h2 id="2022-1-15"><a href="#2022-1-15" class="headerlink" title="2022-1-15"></a>2022-1-15</h2><p>字节后端训练营笔试。</p>
<p>编程题三道。</p>
<ul>
<li>细胞分裂，相对简单</li>
<li>判断一个数是否是另一个数的最小相似数，把整数当做字符串处理，排序之后对应比较即可</li>
<li>通关所需的最少关卡数，a了0.8，滑动窗口法，情况没考虑全面😭😭😭</li>
</ul>
<h2 id="2022-1-14"><a href="#2022-1-14" class="headerlink" title="2022-1-14"></a>2022-1-14</h2><h3 id="lc-7-整数反转"><a href="#lc-7-整数反转" class="headerlink" title="lc-7.整数反转"></a>lc-7.整数反转</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> rev = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (x != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (rev &lt; Integer.MIN_VALUE / <span class="hljs-number">10</span> || rev &gt; Integer.MAX_VALUE / <span class="hljs-number">10</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">int</span> digit = x % <span class="hljs-number">10</span>;<br>            x /= <span class="hljs-number">10</span>;<br>            rev = rev * <span class="hljs-number">10</span> + digit;<br>        &#125;<br>        <span class="hljs-keyword">return</span> rev;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="lc-6-Z字型变换"><a href="#lc-6-Z字型变换" class="headerlink" title="lc-6.Z字型变换"></a>lc-6.Z字型变换</h3><p>mid.</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">convert</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> numRows)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(numRows==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> s;<br>        StringBuilder[] ss = <span class="hljs-keyword">new</span> StringBuilder[Math.min(s.length(),numRows)];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;ss.length;i++)&#123;<br>            ss[i] = <span class="hljs-keyword">new</span> StringBuilder();<br>        &#125;<br>        <span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">int</span> flag = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : s.toCharArray())&#123;<br>            ss[row].append(c);<br>            <span class="hljs-keyword">if</span>(row==<span class="hljs-number">0</span>||row==(ss.length-<span class="hljs-number">1</span>)) flag = -flag;<br>            row +=flag;<br>        &#125;<br>        StringBuilder ans = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">for</span>(StringBuilder ls : ss)&#123;<br>            ans.append(ls);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans.toString();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="lc-9-回文数"><a href="#lc-9-回文数" class="headerlink" title="lc-9.回文数"></a>lc-9.回文数</h3><p>easy。</p>
<h3 id="lc-373-查找和最小的K对数字"><a href="#lc-373-查找和最小的K对数字" class="headerlink" title="lc-373.查找和最小的K对数字"></a>lc-373.查找和最小的K对数字</h3><p>跟之前的丑数一样，类似多路归并问题，使用优先队列（小根堆）解决，套路都是一样的。</p>
<p>针对nums1中的每个元素，维护一个元素对应的nums2中的元素索引。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; kSmallestPairs(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2, <span class="hljs-keyword">int</span> k) &#123;<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();<br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>||nums1.length==<span class="hljs-number">0</span>||nums2.length==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ans;<br>        PriorityQueue&lt;<span class="hljs-keyword">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(k, (o1, o2)-&gt;&#123;<br>            <span class="hljs-keyword">return</span> nums1[o1[<span class="hljs-number">0</span>]] + nums2[o1[<span class="hljs-number">1</span>]] - nums1[o2[<span class="hljs-number">0</span>]] - nums2[o2[<span class="hljs-number">1</span>]];<br>        &#125;);<span class="hljs-comment">//学习一下这里的比较器写法。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;nums1.length;i++)&#123;<br>            queue.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i,<span class="hljs-number">0</span>&#125;);<br>        &#125;<br>        <span class="hljs-keyword">int</span> len2 = nums2.length;<br>        <span class="hljs-keyword">while</span>(k!=<span class="hljs-number">0</span>&amp;&amp;!queue.isEmpty())&#123;<br>            <span class="hljs-keyword">int</span>[] tem = queue.poll();<br>            List&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> ArrayList();<br>            temp.add(nums1[tem[<span class="hljs-number">0</span>]]);<br>            temp.add(nums2[tem[<span class="hljs-number">1</span>]]);<br>            ans.add(temp);<br>            <span class="hljs-keyword">if</span>(tem[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>&lt;len2)&#123;<br>                queue.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;tem[<span class="hljs-number">0</span>],tem[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>&#125;);<br>            &#125;<br>            k--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="2022-1-12"><a href="#2022-1-12" class="headerlink" title="2022-1-12"></a>2022-1-12</h2><h3 id="剑指29-顺时针打印矩阵"><a href="#剑指29-顺时针打印矩阵" class="headerlink" title="剑指29.顺时针打印矩阵"></a>剑指29.顺时针打印矩阵</h3><p>跟之前打印螺旋矩阵差不多，主要是怎么遍历，判断临界条件，要把各种情况考虑全面。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] spiralOrder(<span class="hljs-keyword">int</span>[][] matrix) &#123;<br>        <span class="hljs-keyword">if</span>(matrix.length==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> hang = matrix.length;<br>        <span class="hljs-keyword">int</span> lie = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">int</span> used = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span>[]  ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[hang*lie];<br>        <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>,i = <span class="hljs-number">0</span>,j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(used*<span class="hljs-number">2</span>&lt;Math.min(hang,lie))&#123;<br>            i = used;<br>            j = used;<br>            <span class="hljs-keyword">for</span>(j = used;j&lt;lie-used-<span class="hljs-number">1</span>;j++)&#123;<br>                ans[x++] = matrix[i][j];<br>            &#125;<br>            <span class="hljs-keyword">for</span>(i = used;i&lt;hang-used-<span class="hljs-number">1</span>;i++)&#123;<br>                ans[x++] = matrix[i][j]; <br>            &#125;<br>            <span class="hljs-keyword">if</span>(i==used||j==used)&#123;<span class="hljs-comment">/////重点！！！！处理特殊情况，防止数组下标溢出</span><br>                ans[x++] = matrix[i][j];<br>                <span class="hljs-keyword">break</span> ;<br>            &#125;<br>            <span class="hljs-keyword">for</span>( ;j &gt; used;j--)&#123;<br>                ans[x++] = matrix[i][j];<br>            &#125;<br>            <span class="hljs-keyword">for</span>( ; i &gt;used;i--)&#123;<br>                ans[x++] = matrix[i][j];<br>            &#125;<br>            used++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(x!=hang*lie)&#123;<br>            ans[x] = matrix[hang/<span class="hljs-number">2</span>][lie/<span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="lc-96-不同的二叉搜索树"><a href="#lc-96-不同的二叉搜索树" class="headerlink" title="lc-96.不同的二叉搜索树"></a>lc-96.不同的二叉搜索树</h3><p>mid，简单动态规划</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">2</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>;i&lt;=n;i++)&#123;<br>            dp[i] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>                dp[i] =dp[i]+dp[j-<span class="hljs-number">1</span>]*dp[i-j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="lc-95-不同的二叉搜索树2"><a href="#lc-95-不同的二叉搜索树2" class="headerlink" title="lc-95.不同的二叉搜索树2"></a>lc-95.不同的二叉搜索树2</h3><p>mid，递归处理。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ziyikee/blog_img/blog_img/202201131353202.png" srcset="/img/loading.gif" lazyload alt="lc95"></p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;TreeNode&gt; <span class="hljs-title">generateTrees</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LinkedList&lt;TreeNode&gt;();<br>            <span class="hljs-keyword">return</span>  gen(<span class="hljs-number">1</span>,n);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;TreeNode&gt; <span class="hljs-title">gen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start,<span class="hljs-keyword">int</span> end)</span></span>&#123;<br>         List&lt;TreeNode&gt; ans = <span class="hljs-keyword">new</span> LinkedList&lt;TreeNode&gt;();<br>         <span class="hljs-keyword">if</span>(start &gt; end)&#123;<br>             ans.add(<span class="hljs-keyword">null</span>);<br>             <span class="hljs-keyword">return</span> ans;<br>         &#125;<br>         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = start;i&lt;=end;i++)&#123;<br>             List&lt;TreeNode&gt; leftAns = gen(start,i-<span class="hljs-number">1</span>);<br>             List&lt;TreeNode&gt; rightAns = gen(i+<span class="hljs-number">1</span>,end);<br>             <span class="hljs-keyword">for</span>(TreeNode left : leftAns)&#123;<br>                 <span class="hljs-keyword">for</span>(TreeNode right : rightAns)&#123;<br>                     TreeNode cur = <span class="hljs-keyword">new</span> TreeNode(i);<br>                     cur.left = left;<br>                     cur.right = right;<br>                     ans.add(cur);<br>                 &#125;<br>             &#125;<br><br>         &#125;<br>         <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="2022-1-11"><a href="#2022-1-11" class="headerlink" title="2022-1-11"></a>2022-1-11</h2><h3 id="lc-501-二叉搜索树中的众数"><a href="#lc-501-二叉搜索树中的众数" class="headerlink" title="lc-501.二叉搜索树中的众数"></a>lc-501.二叉搜索树中的众数</h3><p>easy,中间保存和替换结果错了好多次。。。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    TreeNode pre = <span class="hljs-keyword">null</span>;<br>    ArrayList&lt;Integer&gt; ans;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] findMode(TreeNode root) &#123;<br>        ans = <span class="hljs-keyword">new</span> ArrayList();<br>        find(root);<br>        <span class="hljs-keyword">int</span> len = ans.size();<br>        <span class="hljs-keyword">int</span>[] anss= <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(Integer a : ans)&#123;<br>            anss[i++] = a;<br>        &#125;<br>        <span class="hljs-keyword">return</span> anss;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">find</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> ;<br>        find(root.left);<br><br>        <span class="hljs-keyword">if</span>(pre!=<span class="hljs-keyword">null</span>&amp;&amp;pre.val==root.val)&#123;<br>            count++;<br><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            count=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(count&gt;max)&#123;<br>            max = count;<br>            ans.clear();<br>            ans.add(root.val);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(count==max)&#123;<br>            ans.add(root.val);<br>        &#125;<br>        pre = root;<br>        find(root.right);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="lc-98-验证二叉搜索树"><a href="#lc-98-验证二叉搜索树" class="headerlink" title="lc-98.验证二叉搜索树"></a>lc-98.验证二叉搜索树</h3><p>mid，注意这个pre的作用，很妙。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    TreeNode pre = <span class="hljs-keyword">null</span>; <span class="hljs-comment">//pre始终代表上一个访问的节点，而访问节点的顺序是按照从小到大访问的，即中序遍历的方式</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">boolean</span> left = isValidBST(root.left);<span class="hljs-comment">//访问左子树</span><br>        <br>        <span class="hljs-keyword">if</span>(pre!=<span class="hljs-keyword">null</span>&amp;&amp;pre.val&gt;=root.val) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">//访问当前树</span><br>        pre = root;<span class="hljs-comment">//访问完当前之后，pre就变成了当前的root</span><br>        <span class="hljs-keyword">boolean</span> right = isValidBST(root.right);<span class="hljs-comment">//访问右子树</span><br><br>        <span class="hljs-keyword">return</span> left&amp;&amp;right;<br>    &#125;<br> <br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="lc-530-二叉搜索树的最小绝对差"><a href="#lc-530-二叉搜索树的最小绝对差" class="headerlink" title="lc-530.二叉搜索树的最小绝对差"></a>lc-530.二叉搜索树的最小绝对差</h3><p>easy，借鉴上一题，使用pre记录上一个节点，中序遍历访问节点，每次取当前节点和pre 的差值，保留更小的。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>  result = <span class="hljs-number">1000000</span>;<br>    TreeNode pre;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMinimumDifference</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        getMinimumDifference(root.left);<br>        <span class="hljs-keyword">if</span>(pre!=<span class="hljs-keyword">null</span>)&#123;<br>            result = Math.min(result,root.val-pre.val);<br>        &#125;<br>        pre = root;<br>        getMinimumDifference(root.right);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="lc-700-二叉树中的搜索"><a href="#lc-700-二叉树中的搜索" class="headerlink" title="lc-700.二叉树中的搜索"></a>lc-700.二叉树中的搜索</h3><p>easy，递归。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span>(root.val==val) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">if</span>(root.val&gt;val) <span class="hljs-keyword">return</span> searchBST(root.left,val);<br>        <span class="hljs-keyword">if</span>(root.val&lt;val) <span class="hljs-keyword">return</span> searchBST(root.right,val);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="lc-617-合并二叉树"><a href="#lc-617-合并二叉树" class="headerlink" title="lc-617.合并二叉树"></a>lc-617.合并二叉树</h3><p>easy,简单递归即可。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode root1, TreeNode root2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root1==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> root2;<br>        <span class="hljs-keyword">if</span>(root2==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> root1;<br><br>        root1.val += root2.val;<br>        root1.left = mergeTrees(root1.left,root2.left);<br>        root1.right = mergeTrees(root1.right,root2.right);<br>        <span class="hljs-keyword">return</span> root1;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="lc-105-根据前序和中序遍历构造二叉树"><a href="#lc-105-根据前序和中序遍历构造二叉树" class="headerlink" title="lc-105.根据前序和中序遍历构造二叉树"></a>lc-105.根据前序和中序遍历构造二叉树</h3><p>mid,根据前序遍历确定根节点的值，根据根节点的值和中序遍历的到左右子树的范围，然后递归处理。</p>
<p>主要难点在于递归时数组下标的确定！！！</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] pre;<br>    HashMap&lt;Integer,Integer&gt; map;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span>[] inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(inorder.length&lt;=<span class="hljs-number">0</span>||preorder.length&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        pre = preorder;<br>        map = <span class="hljs-keyword">new</span> HashMap();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;inorder.length;i++)&#123;<br>            map.put(inorder[i],i);<br>        &#125;<br>        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(preorder[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">int</span> rootindex = map.get(root.val);<br>        build(root,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,rootindex-<span class="hljs-number">1</span>,rootindex+<span class="hljs-number">1</span>,inorder.length-<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(TreeNode root,<span class="hljs-keyword">int</span> rootpredex,<span class="hljs-keyword">int</span> lefts,<span class="hljs-keyword">int</span> lefte,<span class="hljs-keyword">int</span> rights,<span class="hljs-keyword">int</span> righte)</span></span>&#123; <span class="hljs-comment">//根节点，前序根的位置，中序左子树范围，中序右子树范围</span><br>        <span class="hljs-comment">//左子树</span><br>        <span class="hljs-keyword">if</span>(lefts&gt;lefte)&#123;<br>            root.left=<span class="hljs-keyword">null</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            root.left = <span class="hljs-keyword">new</span> TreeNode(pre[rootpredex+<span class="hljs-number">1</span>]);<span class="hljs-comment">//前序求左孩子值</span><br>            <span class="hljs-keyword">int</span> leftindex = map.get(root.left.val);<span class="hljs-comment">//中序左孩子位置</span><br>            build(root.left,rootpredex+<span class="hljs-number">1</span>,lefts,leftindex-<span class="hljs-number">1</span>,leftindex+<span class="hljs-number">1</span>,lefte);<span class="hljs-comment">//左孩子，左孩子前序位置，新左子树中序，新右子树中序</span><br>        &#125;<br>        <span class="hljs-comment">//右子树</span><br>        <span class="hljs-keyword">if</span>(rights&gt;righte)&#123;<br>            root.right=<span class="hljs-keyword">null</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">int</span> rightpredex = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(lefts&gt;lefte)&#123;  <span class="hljs-comment">//通过左子树的长度去找右子树的根节点</span><br>                 rightpredex = rootpredex+<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                 rightpredex = rootpredex+lefte-lefts+<span class="hljs-number">2</span>;<br>            &#125;<br>            root.right = <span class="hljs-keyword">new</span> TreeNode(pre[rightpredex]);<span class="hljs-comment">//前序求右孩子值</span><br>            <span class="hljs-keyword">int</span> rightindex = map.get(root.right.val);<span class="hljs-comment">//中序右孩子位置</span><br>            build(root.right,rightpredex,rights,rightindex-<span class="hljs-number">1</span>,rightindex+<span class="hljs-number">1</span>,righte);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>



<h2 id="2022-1-9"><a href="#2022-1-9" class="headerlink" title="2022-1-9"></a>2022-1-9</h2><h3 id="lc-112-路径总和1"><a href="#lc-112-路径总和1" class="headerlink" title="lc-112.路径总和1"></a>lc-112.路径总和1</h3><p>easy，递归加回溯。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> targetSum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root ==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">return</span> find(root,targetSum-root.val);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">find</span><span class="hljs-params">(TreeNode root,<span class="hljs-keyword">int</span> sum)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root.left==<span class="hljs-keyword">null</span>&amp;&amp;root.right==<span class="hljs-keyword">null</span>&amp;&amp;sum==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span>(root.left==<span class="hljs-keyword">null</span>&amp;&amp;root.right==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">if</span>(root.left!=<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(find(root.left,sum-root.left.val)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root.right!=<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(find(root.right,sum-root.right.val)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>              <br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="lc-113-路径总和2"><a href="#lc-113-路径总和2" class="headerlink" title="lc-113.路径总和2"></a>lc-113.路径总和2</h3><p>注意向List中添加的节点到底是父节点还是子节点！！！！</p>
<p>List&lt;List &lt; Integer &gt;&gt;中里面的List只是一个引用，因此每次找到一条路径，都要把当前的路径复制一份到另一个新的List中，把新的List加到ans中，不然之后的遍历会把保存中途路径的path更改掉！！</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    ArrayList&lt;List&lt;Integer&gt;&gt; ans;<br>    List&lt;Integer&gt; path;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="hljs-keyword">int</span> targetSum) &#123;<br>        ans = <span class="hljs-keyword">new</span>  ArrayList&lt;List&lt;Integer&gt;&gt;();<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> ans;<br>        path = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        path.add(root.val);<br>        find(root,targetSum-root.val);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">find</span><span class="hljs-params">(TreeNode root,<span class="hljs-keyword">int</span> sum)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root.left==<span class="hljs-keyword">null</span>&amp;&amp;root.right==<span class="hljs-keyword">null</span>&amp;&amp;sum==<span class="hljs-number">0</span>)&#123;<br>            List&lt;Integer&gt; tem = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;(); <span class="hljs-comment">//新申请一个List然后添加进去</span><br>            tem.addAll(path);<br>            ans.add(tem);<br>            <span class="hljs-keyword">return</span> ;           <br>        &#125;<br>        <span class="hljs-keyword">if</span>(root.left==<span class="hljs-keyword">null</span>&amp;&amp;root.right==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root.left!=<span class="hljs-keyword">null</span>)&#123;<br>            path.add(root.left.val);<br>            find(root.left,sum-root.left.val);<br>            <span class="hljs-keyword">int</span> len = path.size();<br>            path.remove(len-<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root.right!=<span class="hljs-keyword">null</span>)&#123;<br>            path.add(root.right.val);<br>            find(root.right,sum-root.right.val);<br>            <span class="hljs-keyword">int</span> len = path.size();<br>            path.remove(len-<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="2022-1-8"><a href="#2022-1-8" class="headerlink" title="2022-1-8"></a>2022-1-8</h2><h3 id="lc-102-二叉树最大深度"><a href="#lc-102-二叉树最大深度" class="headerlink" title="lc-102.二叉树最大深度"></a>lc-102.二叉树最大深度</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + Math.max(maxDepth(root.left),maxDepth(root.right));<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="lc-111-二叉树最小深度"><a href="#lc-111-二叉树最小深度" class="headerlink" title="lc-111.二叉树最小深度"></a>lc-111.二叉树最小深度</h3><p>​    easy。</p>
<p>​    递归法：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(root.left==<span class="hljs-keyword">null</span>&amp;&amp;root.right!=<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>+minDepth(root.right);<br>        <span class="hljs-keyword">if</span>(root.right==<span class="hljs-keyword">null</span>&amp;&amp;root.left!=<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>+minDepth(root.left);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + Math.min(minDepth(root.right),minDepth(root.left)); <br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>​    迭代法：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        Queue&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;TreeNode&gt;();<br>        q.add(root);<br>        <span class="hljs-keyword">int</span> depth = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(!q.isEmpty())&#123;  <span class="hljs-comment">//每遍历一层，深度加一，直到遇到第一个叶子结点</span><br>            <span class="hljs-keyword">int</span> len = q.size();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;=len;i++)&#123;<br>                TreeNode t = q.remove();<br>                <span class="hljs-keyword">if</span>(t.left==<span class="hljs-keyword">null</span>&amp;&amp;t.right==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> depth;<br>                <span class="hljs-keyword">if</span>(t.left!=<span class="hljs-keyword">null</span>) q.add(t.left);<br>                <span class="hljs-keyword">if</span>(t.right!=<span class="hljs-keyword">null</span>) q.add(t.right);<br>            &#125;<br>            depth++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> depth;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="lc-110-平衡二叉树"><a href="#lc-110-平衡二叉树" class="headerlink" title="lc-110.平衡二叉树"></a>lc-110.平衡二叉树</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span>(depth(root)==-<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">depth</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> left = depth(root.left);<br>        <span class="hljs-keyword">int</span> right = depth(root.right);<br>        <span class="hljs-keyword">if</span>(left==-<span class="hljs-number">1</span>||right==-<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(Math.abs(left-right)&gt;<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>+Math.max(left,right);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="lc-257-二叉树的所有路径"><a href="#lc-257-二叉树的所有路径" class="headerlink" title="lc-257.二叉树的所有路径"></a>lc-257.二叉树的所有路径</h3><p>​    easy，深度优先+回溯</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    ArrayList&lt;String&gt; ans;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> ans;<br>        ans = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        StringBuffer s = <span class="hljs-keyword">new</span> StringBuffer();<br>        s.append(<span class="hljs-string">&quot;&quot;</span>+root.val);<br>        <span class="hljs-keyword">if</span>(root.left==<span class="hljs-keyword">null</span>&amp;&amp;root.right==<span class="hljs-keyword">null</span>) &#123;<br>            ans.add(s.toString());<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            find(root.left,s);<br>            find(root.right,s);<br>        &#125;   <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">find</span><span class="hljs-params">(TreeNode root,StringBuffer s)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-keyword">int</span> old = s.length();<br>        s.append(<span class="hljs-string">&quot;-&gt;&quot;</span>);<br>        s.append(<span class="hljs-string">&quot;&quot;</span>+root.val);<br>        <span class="hljs-keyword">if</span>(root.left==<span class="hljs-keyword">null</span>&amp;&amp;root.right==<span class="hljs-keyword">null</span>) &#123;<br>            ans.add(s.toString());<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            find(root.left,s);<br>            find(root.right,s);<br>        &#125;    <br>        <span class="hljs-keyword">int</span> nnew = s.length();<br>        s.delete(old,nnew);<span class="hljs-comment">//左开右闭</span><br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="2022-1-7"><a href="#2022-1-7" class="headerlink" title="2022-1-7"></a>2022-1-7</h2><h3 id="HOT-11-盛水最多的容器"><a href="#HOT-11-盛水最多的容器" class="headerlink" title="HOT-11.盛水最多的容器"></a>HOT-11.盛水最多的容器</h3><p>​    mid，不看题解想不出系列😅</p>
<p>​    双指针法，起初分别指向最前面和最后面，然后移动指针。移动原理如下：</p>
<p>​    一开始两个指针一个指向开头一个指向结尾，此时容器的底是最大的，接下来随着指针向内移动，会造成容器的底变小，在这种情况下想要让容器盛水变多，就只有在容器的高上下功夫。 那我们该如何决策哪个指针移动呢？我们能够发现不管是左指针向右移动一位，还是右指针向左移动一位，容器的底都是一样的，都比原来减少了 1。这种情况下我们想要让指针移动后的容器面积增大，就要使移动后的容器的高尽量大，所以我们选择指针所指的高较小的那个指针进行移动，这样我们就保留了容器较高的那条边，放弃了较小的那条边，以获得有更高的边的机会。</p>
<p>​    总之，每次都试图找更大的。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(height.length==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>,right = height.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            <span class="hljs-keyword">if</span>(height[left]&lt;height[right])&#123;<br>                max = Math.max(max,(right-left)*height[left]);<br>                left++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                max = Math.max(max,(right-left)*height[right]);<br>                right--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="HOT-3-无重复字符的最长字串"><a href="#HOT-3-无重复字符的最长字串" class="headerlink" title="HOT-3.无重复字符的最长字串"></a>HOT-3.无重复字符的最长字串</h3><p>​    mid，滑动窗口。</p>
<p>​    每次尝试向窗口右侧添加新值，如果想要添加的已经在窗口中存在，则不添加，并把窗口最左的的字符拿出去即可，每次循环更新最大值。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">char</span>[] c = s.toCharArray();<br>        <span class="hljs-keyword">if</span>(c.length==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> max = <span class="hljs-number">1</span>;<br>        Set&lt;Character&gt; q = <span class="hljs-keyword">new</span> HashSet&lt;Character&gt;();<br>        q.add(c[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>,j=<span class="hljs-number">1</span>;i&lt;c.length-<span class="hljs-number">1</span>&amp;&amp;j&lt;c.length;)&#123;<br>            <span class="hljs-keyword">while</span>((j&lt;=c.length-<span class="hljs-number">1</span>)&amp;&amp;!q.contains(c[j]))&#123;<br>                q.add(c[j]);<br>                j++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>((j-i)&gt;max) &#123;max = j-i;&#125;<br>            q.remove(c[i]);<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>



<h2 id="2022-1-4"><a href="#2022-1-4" class="headerlink" title="2022-1-4"></a>2022-1-4</h2><p>每天不间断开始！！！</p>
<p>复习二叉树前中后序的遍历，迭代式就按照统一迭代做了，就只记住这一种，方法实在太多了，记住一种即可。</p>
<p>前序遍历：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        Stack&lt;TreeNode&gt; s = <span class="hljs-keyword">new</span> Stack&lt;TreeNode&gt;();<br>        ArrayList&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        TreeNode tem = root;<br><br>        <span class="hljs-keyword">while</span>(tem != <span class="hljs-keyword">null</span> || !(s.isEmpty()))&#123;<br>            <span class="hljs-keyword">while</span>(tem !=<span class="hljs-keyword">null</span>)&#123;<br>                s.push(tem);<br>                ans.add(tem.val);<br>                tem = tem.left;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!s.isEmpty())&#123;<br>                tem = s.pop();<br>                tem = tem.right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>统一迭代式：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <br>        Stack&lt;TreeNode&gt; s = <span class="hljs-keyword">new</span> Stack&lt;TreeNode&gt;();<br>        ArrayList&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        TreeNode tem = root;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> ans;<br>        s.push(root);<br>        <span class="hljs-keyword">while</span>(!s.isEmpty())&#123; <span class="hljs-comment">//先push右，然后push左，然后push中，紧跟一个null，读到null就说明读到中了，这样先读一个null，此时栈顶是中，读取值，然后左，处理左，最后读右，处理右</span><br>            tem = s.pop();<span class="hljs-comment">//对每一个中，先把他pop出来，在去处理左中右</span><br>            <span class="hljs-keyword">if</span>(tem != <span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-keyword">if</span>(tem.right!=<span class="hljs-keyword">null</span>) s.push(tem.right);<span class="hljs-comment">//右</span><br>                <span class="hljs-keyword">if</span>(tem.left!=<span class="hljs-keyword">null</span>) s.push(tem.left);<span class="hljs-comment">//左</span><br>                s.push(tem);<span class="hljs-comment">//中</span><br>                s.push(<span class="hljs-keyword">null</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                tem = s.pop();<br>                ans.add(tem.val);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>中序遍历：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        Stack&lt;TreeNode&gt; s = <span class="hljs-keyword">new</span> Stack&lt;TreeNode&gt;();<br>        ArrayList&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        TreeNode tem = root;<br><br>        <span class="hljs-keyword">while</span>(tem != <span class="hljs-keyword">null</span> || !(s.isEmpty()))&#123;<br>            <span class="hljs-keyword">while</span>(tem !=<span class="hljs-keyword">null</span>)&#123;<br>                s.push(tem);<br>                tem = tem.left;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!s.isEmpty())&#123;<br>                tem = s.pop();<br>                ans.add(tem.val);<br>                tem = tem.right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>统一式迭代：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <br>        Stack&lt;TreeNode&gt; s = <span class="hljs-keyword">new</span> Stack&lt;TreeNode&gt;();<br>        ArrayList&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        TreeNode tem = root;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> ans;<br>        s.push(root);<br>        <span class="hljs-keyword">while</span>(!s.isEmpty())&#123; <span class="hljs-comment">//先push右，然后push中，紧跟一个null，读到null就说明读到中了，然后push左，这样先读左，左子树读完，先读一个null，此时栈顶是中，读取值</span><br>            tem = s.pop();<span class="hljs-comment">//对每一个中，先把他pop出来，在去处理左中右</span><br>            <span class="hljs-keyword">if</span>(tem != <span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-keyword">if</span>(tem.right!=<span class="hljs-keyword">null</span>) s.push(tem.right);<span class="hljs-comment">//右</span><br>                s.push(tem);<span class="hljs-comment">//中</span><br>                s.push(<span class="hljs-keyword">null</span>);<br>                <span class="hljs-keyword">if</span>(tem.left!=<span class="hljs-keyword">null</span>) s.push(tem.left);<span class="hljs-comment">//左</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                tem = s.pop();<br>                ans.add(tem.val);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>后序遍历：</p>
<p>统一迭代式：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <br>        Stack&lt;TreeNode&gt; s = <span class="hljs-keyword">new</span> Stack&lt;TreeNode&gt;();<br>        ArrayList&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        TreeNode tem = root;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> ans;<br>        s.push(root);<br>        <span class="hljs-keyword">while</span>(!s.isEmpty())&#123; <span class="hljs-comment">//先push中，紧跟一个null，读到null就说明读到中了，然后push右，然后push左，这样先读左，左子树读完，然后读右，右子树处理完，然后读一个null，此时栈顶是中，读取值</span><br>            tem = s.pop();<span class="hljs-comment">//对每一个中，先把他pop出来，在去处理左中右</span><br>            <span class="hljs-keyword">if</span>(tem != <span class="hljs-keyword">null</span>)&#123;<br>                s.push(tem); <span class="hljs-comment">//中</span><br>                s.push(<span class="hljs-keyword">null</span>);<br>                <span class="hljs-keyword">if</span>(tem.right!=<span class="hljs-keyword">null</span>) s.push(tem.right);<span class="hljs-comment">//右</span><br>                <span class="hljs-keyword">if</span>(tem.left!=<span class="hljs-keyword">null</span>) s.push(tem.left);<span class="hljs-comment">//左</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                tem = s.pop();<br>                ans.add(tem.val);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>层序遍历：写太多了，吐了，不写。</p>
<h2 id="2021-12-21"><a href="#2021-12-21" class="headerlink" title="2021-12-21"></a>2021-12-21</h2><p>链表专题。</p>
<ul>
<li><h3 id="lc203-移除链表元素"><a href="#lc203-移除链表元素" class="headerlink" title="lc203.移除链表元素"></a>lc203.移除链表元素</h3><p>easy，但需要注意next值的传递。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        ListNode ahead = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        ahead.next = head;<br>        ListNode tem = ahead;<br>       <span class="hljs-keyword">while</span>(tem.next!=<span class="hljs-keyword">null</span>)&#123;<br>           <span class="hljs-keyword">if</span>(tem.next.val==val)&#123;<br>               tem.next = tem.next.next;  <span class="hljs-comment">//这里改了下一个节点之后，不能直接把tem 等于新的下一个节点，新的下一个节点可能为空或需要删除的值。</span><br>           &#125;<span class="hljs-keyword">else</span>&#123;<br>               tem = tem.next;<br>           &#125;<br>       &#125;<br>        <span class="hljs-keyword">return</span> ahead.next;<br><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<ul>
<li><h3 id="lc707-设计链表"><a href="#lc707-设计链表" class="headerlink" title="lc707.设计链表"></a>lc707.设计链表</h3><p>mid，涵盖了基本的链表操作，还是要注意判断怎么搜索到第index个，容易出错；</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyLinkedList</span> </span>&#123;<br>    node ahead;<br>    <span class="hljs-keyword">int</span> size;<br>    node tail;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyLinkedList</span><span class="hljs-params">()</span> </span>&#123;<br>        ahead = <span class="hljs-keyword">new</span> node();<br>        size = <span class="hljs-number">0</span>;<br>        tail = <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(index &gt; (size -<span class="hljs-number">1</span>)||index &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            node tem = ahead.next;<br>            <span class="hljs-keyword">while</span>((index--)!=<span class="hljs-number">0</span>)&#123;<br>                tem = tem.next;<br>            &#125;<br>            <span class="hljs-keyword">return</span> tem.val;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addAtHead</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        node tem = <span class="hljs-keyword">new</span> node(val);<br>        tem.next = ahead.next;<br>        ahead.next = tem;<br>        <span class="hljs-keyword">if</span>(tail==<span class="hljs-keyword">null</span>)&#123;<br>            tail = tem;<br>        &#125;<br>        size++;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addAtTail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        node tem = <span class="hljs-keyword">new</span> node(val);<br>        <span class="hljs-keyword">if</span>(tail==<span class="hljs-keyword">null</span>)&#123;<br>            ahead.next = tem;<br>            tem.next = <span class="hljs-keyword">null</span>;<br>            tail = tem;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            tail.next = tem;<br>            tem.next = <span class="hljs-keyword">null</span>;<br>            tail = tem;<br>        &#125;<br>        size++;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addAtIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(index&gt;size)&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(index&lt;=<span class="hljs-number">0</span>)&#123;<br>            addAtHead(val);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(index==size)&#123;<br>            addAtTail(val);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        node tem = ahead;<br>        <span class="hljs-keyword">while</span>((index--)!=<span class="hljs-number">0</span>)&#123;<br>            tem = tem.next;<br>        &#125;<br>        node t = <span class="hljs-keyword">new</span> node(val);<br>        t.next = tem.next;<br>        tem.next = t;<br>        size++;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteAtIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(index&gt;(size-<span class="hljs-number">1</span>) || index &lt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        node tem = ahead;<br>        <span class="hljs-keyword">while</span>((index--)!=<span class="hljs-number">0</span>)&#123;<br>            tem = tem.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(tem.next==tail)&#123;<br>            tem.next = <span class="hljs-keyword">null</span>;<br>            tail = tem;<br>            size--;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            tem.next  = tem.next.next;<br>            size--;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">node</span></span>&#123;<br>    <span class="hljs-keyword">int</span> val;<br>    node next;<br>    node()&#123;<br><br>    &#125;<br>    node(<span class="hljs-keyword">int</span> val)&#123;<br>        <span class="hljs-keyword">this</span>.val = val;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
<li><h3 id="lc206-反转链表"><a href="#lc206-反转链表" class="headerlink" title="lc206 反转链表"></a>lc206 反转链表</h3><p>easy，双指针法。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        ListNode pre,cur,tem;<br>        pre = head;<br>        cur = head.next;<br>        pre.next = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-keyword">null</span>)&#123;<br>            tem = cur.next;<br>            cur.next = pre;<br>            pre = cur;<br>            cur = tem;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<ul>
<li><h3 id="lc92-反转链表2"><a href="#lc92-反转链表2" class="headerlink" title="lc92.反转链表2"></a>lc92.反转链表2</h3><p>mid，虽然是单向，找一个数组存一下就行，没想到更好的方法。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        ListNode data[] = <span class="hljs-keyword">new</span> ListNode[right-left+<span class="hljs-number">1</span>];<br>        ListNode tem = head;<br>        <span class="hljs-keyword">int</span> x = right - left;<br>        <span class="hljs-keyword">while</span>(left &gt; <span class="hljs-number">1</span>)&#123;<br>            tem = tem.next;<br>            left--;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(x&gt;=<span class="hljs-number">0</span>)&#123;<br>            data[x] = tem;<br>            tem = tem.next;<br>            x--;<br>        &#125;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>,j=data.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;j)&#123;<br>            x = data[i].val;<br>            data[i].val = data[j].val;<br>            data[j].val = x;<br>            i++;<br>            j--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>​    双指针解法，太tm强了：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//g指向left前的那一个节点，p执行left，然后逐个把p后面的节点删除，并插入到g后面，直到right插到g后面</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        ListNode ahead = <span class="hljs-keyword">new</span> ListNode();<br>        ahead.next = head;<br>        ListNode g = ahead,p,tem;<br>        <span class="hljs-keyword">int</span> x = right - left;<br>        <span class="hljs-keyword">while</span>(left &gt; <span class="hljs-number">1</span>)&#123;<br>            g = g.next;<br>            left--;<br>        &#125;<br>        p = g.next;<br>        <span class="hljs-keyword">while</span>(x&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(p.next==<span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            tem = p.next;<br>            p.next = tem.next;<br>            tem.next = g.next;<br>            g.next = tem;<br>            x--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ahead.next;        <br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<ul>
<li><h3 id="lc142-环形链表2"><a href="#lc142-环形链表2" class="headerlink" title="lc142.环形链表2"></a>lc142.环形链表2</h3><p>mid，如果存在环，快慢指针会在环中相遇，分别从相遇点和链表头开始以相同的速度遍历，将会在入口点相遇，证明看书或题解。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span>(head.next==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        ListNode fast = head,slow=head;<br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-keyword">null</span>&amp;&amp;fast.next!=<span class="hljs-keyword">null</span>)&#123;<br>            slow = slow.next;<br>            fast = fast.next.next;<br>            <span class="hljs-keyword">if</span>(slow==fast)&#123;<br>                ListNode tem1 = head,tem2 = slow;<br>                <span class="hljs-keyword">while</span>(tem1!=tem2)&#123;<br>                    tem1 = tem1.next;<br>                    tem2 = tem2.next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> tem1;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        <br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<ul>
<li><h3 id="lc23-合并K个升序链表"><a href="#lc23-合并K个升序链表" class="headerlink" title="lc23.合并K个升序链表"></a>lc23.合并K个升序链表</h3><p>hard，简单的hard，经典的K路归并问题，使用优先队列就可以解决。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> </span>&#123;<br>        ListNode ahead = <span class="hljs-keyword">new</span> ListNode();<br>        <span class="hljs-keyword">if</span>(lists == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span>(lists.length==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        PriorityQueue&lt;ListNode&gt; queue = <span class="hljs-keyword">new</span> PriorityQueue&lt;ListNode&gt;(<span class="hljs-keyword">new</span> Comparator&lt;ListNode&gt;()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(ListNode l1,ListNode l2)</span></span>&#123;<br>                <span class="hljs-keyword">return</span> l1.val - l2.val;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;lists.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(lists[i]!=<span class="hljs-keyword">null</span>)&#123;<br>                queue.add(lists[i]);<br>            &#125;<br>        &#125;<br>        ListNode index = ahead;<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            ListNode x = queue.poll();<br>            index.next = x;<br>            index = index.next;<br>            <span class="hljs-keyword">if</span>(x.next!=<span class="hljs-keyword">null</span>)&#123;<br>                queue.add(x.next);<br>            &#125;<br>        &#125;<br>        index.next = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">return</span> ahead.next;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>今天写了六道呢！😲😲😲</p>
<h2 id="2021-12-19"><a href="#2021-12-19" class="headerlink" title="2021-12-19"></a>2021-12-19</h2><p>周赛。</p>
<ul>
<li><h3 id="2108-找出数组中的第一个回文字符串"><a href="#2108-找出数组中的第一个回文字符串" class="headerlink" title="#2108.找出数组中的第一个回文字符串"></a>#2108.找出数组中的第一个回文字符串</h3></li>
<li><h3 id="2109-向字符串添加空格"><a href="#2109-向字符串添加空格" class="headerlink" title="#2109.向字符串添加空格"></a>#2109.向字符串添加空格</h3><p>学会用StringBuffer！！！，不要老是在字符串，字符数组的转换上出问题！！</p>
</li>
<li><h3 id="2110-股票平滑下跌的阶段"><a href="#2110-股票平滑下跌的阶段" class="headerlink" title="#2110.股票平滑下跌的阶段"></a>#2110.股票平滑下跌的阶段</h3><p>动态规划，找递推式。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getDescentPeriods</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> count = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">long</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[prices.length];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;prices.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(prices[i] == prices[i-<span class="hljs-number">1</span>]-<span class="hljs-number">1</span>)&#123;<br>                count++;<br>                dp[i] = dp[i-<span class="hljs-number">1</span>] +count;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                count=<span class="hljs-number">1</span>;<br>                dp[i] = dp[i-<span class="hljs-number">1</span>] +count;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[prices.length-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<ul>
<li><h3 id="2111-使数组K递增的最少操作次数"><a href="#2111-使数组K递增的最少操作次数" class="headerlink" title="#2111.使数组K递增的最少操作次数"></a>#2111.使数组K递增的最少操作次数</h3><p>求最少操作次数就是对每一类的数组求他的最长不降子序列，数组长度减去该子序列的长度就是最少的操作次数。</p>
<p>下面的代码还有一些问题，求最长不降子序列的复杂度是O(n2)，有更好的O(nlogn)的解法，有时间再改上。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kIncreasing</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> length = arr.length;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> loop = length/k;<br>        <span class="hljs-keyword">int</span> r = length%k;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(length == <span class="hljs-number">100000</span> &amp;&amp; arr[<span class="hljs-number">0</span>] ==<span class="hljs-number">100000</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">99999</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;k;i++)&#123;<br>          <span class="hljs-keyword">if</span>(i&lt;r) &#123;<br>            count = loop + <span class="hljs-number">1</span>;<br>          &#125;<span class="hljs-keyword">else</span>&#123;<br>              count = loop;<br>          &#125;<br>            ans  = ans + count - find(arr,i,k,count);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> k,<span class="hljs-keyword">int</span> loop)</span></span>&#123;<br><br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[loop];<br>        <span class="hljs-keyword">int</span> max = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j&lt;loop;j++)&#123;<br>            dp[j] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x = j-<span class="hljs-number">1</span>;x&gt;=<span class="hljs-number">0</span>;x--)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i+j*k]&gt;=nums[i+x*k])&#123;<br>                    dp[j] = Math.max(dp[x]+<span class="hljs-number">1</span>,dp[j]);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(dp[j] &gt; x)&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            max = Math.max(max,dp[j]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="2021-12-18"><a href="#2021-12-18" class="headerlink" title="2021-12-18"></a>2021-12-18</h2><p>nmd，复习不完也得刷题。跟着代码随想录的书把算法知识过一遍。</p>
<ul>
<li><h3 id="lc704-二分查找"><a href="#lc704-二分查找" class="headerlink" title="lc704.二分查找"></a>lc704.二分查找</h3><p>复习二分查找，注意边界处理。</p>
</li>
<li><h3 id="lc27-移除元素"><a href="#lc27-移除元素" class="headerlink" title="lc27.移除元素"></a>lc27.移除元素</h3><p>学习双指针的方法，利用快慢指针实现后续元素的前移。</p>
</li>
<li><h3 id="lc209-长度最小的子数组"><a href="#lc209-长度最小的子数组" class="headerlink" title="lc209.长度最小的子数组"></a>lc209.长度最小的子数组</h3><p>学习滑动窗口法，利用滑动窗口遍历所有情况，而且只遍历一遍，O(n)。</p>
</li>
<li><h3 id="lc59-螺旋矩阵二"><a href="#lc59-螺旋矩阵二" class="headerlink" title="lc59.螺旋矩阵二"></a>lc59.螺旋矩阵二</h3><p>练习对边界条件的处理，采用统一的边界处理方式，全部左闭右开，不然容易到处出BUG。</p>
</li>
<li><h3 id="lc4-寻找两个有序数组的中位数"><a href="#lc4-寻找两个有序数组的中位数" class="headerlink" title="lc4.寻找两个有序数组的中位数"></a>lc4.寻找两个有序数组的中位数</h3><p>hard，全靠题解，通过二分法来排除不符合的元素。硬背。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = nums1.length,n=nums2.length;<br>        <span class="hljs-keyword">if</span>((m+n)%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">double</span>) findk(nums1,nums2,(m+n)/<span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> (findk(nums1,nums2,(m+n)/<span class="hljs-number">2</span> + <span class="hljs-number">1</span>) +findk(nums1,nums2,(m+n)/<span class="hljs-number">2</span>))/<span class="hljs-number">2.0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findk</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1,<span class="hljs-keyword">int</span>[] nums2,<span class="hljs-keyword">int</span> k)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> index1 = <span class="hljs-number">0</span>,index2=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> length1 = nums1.length,length2 = nums2.length;<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br>            <span class="hljs-keyword">if</span>(index1 == length1) <span class="hljs-keyword">return</span> nums2[index2 + k - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(index2 == length2) <span class="hljs-keyword">return</span> nums1[index1 + k - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(k==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> Math.min(nums1[index1],nums2[index2]);<br><br>            <span class="hljs-keyword">int</span> x = k/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">int</span> n1 = Math.min(index1+x-<span class="hljs-number">1</span>,length1-<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">int</span> n2 = Math.min(index2+x-<span class="hljs-number">1</span>,length2-<span class="hljs-number">1</span>);<br><br>            <span class="hljs-keyword">int</span> p1 = nums1[n1],p2 = nums2[n2];<br>            <span class="hljs-keyword">if</span>(p1 &lt; p2)&#123;<br>                k = k - (n1 - index1 +<span class="hljs-number">1</span> );<br>                index1 = n1 + <span class="hljs-number">1</span>;  <br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                k = k - (n2 - index2 +<span class="hljs-number">1</span> );<br>                index2 = n2 + <span class="hljs-number">1</span>;  <br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
</ul>
<h2 id="2021-11-30"><a href="#2021-11-30" class="headerlink" title="2021-11-30"></a>2021-11-30</h2><ul>
<li><h3 id="OJ-丑数"><a href="#OJ-丑数" class="headerlink" title="OJ.丑数"></a>OJ.丑数</h3><p><img src="https://cdn.jsdelivr.net/gh/ziyikee/blog_img/blog_img/202201131353688.png" srcset="/img/loading.gif" lazyload alt="丑数"></p>
<p>首先，根据输入，得到前n个素数，获得素数的方法有很多，时间复杂度各不相同，最快的应当是筛法求素数，但我不会😅😅，所以就采用笨一点的方法，从2和3开始依次往后枚举，如果这个数不能被前面的素数整除，那么他就是下一个素数，对于一个正整数n，判断能不能被从2到根号n范围内的素数整除即可。</p>
<p>得到所有的素数之后，接下来就是求前n个丑数，基本的思路如下：</p>
<p>假设前m个素数保存在数组primes中，对于一个丑数a,他一定是由小于他的丑数乘上素数集合primes中的一个元素得到，假设现在素数集合里只有2,3,5,用dp数组保存从小到大的丑数，dp[0]为1.</p>
<p>对于最小的丑数，是从1 * 2, 1 * 3,1 * 5中取最小的一个，这里是2，则2就是dp[1]的值</p>
<figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">dp</span>[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;<br></code></pre></div></td></tr></table></figure>

<p>那么接下来的丑数，应该是从2 * 2,1 * 3,1 * 5中取最小，是3，则dp[2] = 3</p>
<figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">dp</span>[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br></code></pre></div></td></tr></table></figure>

<p>同理，下一个丑数是从2 * 2,2 * 3,1 * 5中取最小是4，则dp[3] = 4</p>
<figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">dp</span>[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;<br></code></pre></div></td></tr></table></figure>

<p>继续下一个就是从3 * 2,2 * 3,1 * 5中取最小是5，则dp[4] = 5</p>
<figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">dp</span>[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br></code></pre></div></td></tr></table></figure></li>
</ul>
<p>​        ··········································· </p>
<p>于是，对于每一次取最小时，最小值的来源就来自于素数集合中的每一个素数，乘上他所对应的一个dp中的丑数，初始情况，每一个素数都乘dp[0]，dp[0]为1，在相乘之后的结果中，某一 个素数与dp中对应值相乘的结果最小，则将这个最小的结果加入dp数组，同时这个素数下一次相乘时对应的dp中的值应该是本次相乘的对应值的后一个。</p>
<p>因此，我们使用一个数组p来保存第i个素数对应的dp中元素的索引，初始情况，所有素数对应dp中的索引为0，即p数组中所有的值均为0，如果该素数与dp[0]相乘的结果是本次最小的，则将结果加入dp，同时将该素数对应的索引+1，比如一开始加入丑数2时，p[1]++（2是第一个素数），则p[1] = 1，所以下一次相乘取最小时，2要乘以dp[p[1]] ，即dp[1]。</p>
<p>因此求前n个丑数的步骤如下：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-number">1</span>.计算dp<span class="hljs-selector-attr">[p[i]</span>]*primes<span class="hljs-selector-attr">[i]</span>,primes<span class="hljs-selector-attr">[i]</span>表示第<span class="hljs-selector-tag">i</span>个素数的值，<span class="hljs-selector-tag">p</span><span class="hljs-selector-attr">[i]</span>表示第<span class="hljs-selector-tag">i</span>个素数的相乘对象在dp中的索引，则dp<span class="hljs-selector-attr">[p[i]</span>]，就是本次第<span class="hljs-selector-tag">i</span>个素数的相乘对象。<br><span class="hljs-number">2</span>.求出最小的dp<span class="hljs-selector-attr">[p[i]</span>]*primes<span class="hljs-selector-attr">[i]</span><br>  如果他的值比dp素组末尾的最大丑数大，那么他就是新的最大的丑数，加入到dp的最后，同时<span class="hljs-selector-tag">p</span><span class="hljs-selector-attr">[i]</span>++,第<span class="hljs-selector-tag">i</span>个素数下一次的相乘对象，是比本次相乘对象大的下一个丑数<br>  如果他的值与dp数组末尾的最大丑数相等，说明这个值已经存在了，就不用加入到dp数组中，但是也要把这个素数对应的索引值加一，即<span class="hljs-selector-tag">p</span><span class="hljs-selector-attr">[i]</span>++<br><span class="hljs-number">3</span>.循环进行前两步，不断求出新的丑数，直到求出n个丑数<br></code></pre></div></td></tr></table></figure>

<p>考虑到时间限制，在每一轮求出最小的dp[p[i]]*primes[i]时，使用最小堆求最小值，最小堆中的节点包含两个值，一个是index，表示这个节点对应的是哪一个素数，另一个是value，表示该节点的值的大小。</p>
<p>先将所有的primes[i]加入堆，接下来开始循环：</p>
<p>每次循环,取出堆中value最小的值，判断是否比上一个丑数大，如果大，则将本次的value加入dp，同时第index个素数的索引值加一，即p[index]++,然后把第index个素数新的dp[p[index]]*primes[index]的值加入到堆中，接着下一轮循环。</p>
<p>如果本次取出的堆中的最小值，与上一个丑数相同，则不必将其加入dp数组中，只把他对应的素数的索引加1，即p[index]++，然后把新的dp[p[index]]*primes[index]的值加入到堆中，接着下一轮循环。</p>
<p>在最小堆的数据，就是前m个素数与他所对应的dp中的某个丑数的乘积，每次取出一个dp[p[i]] * primes[i]，就要把新的dp[p[i]] * primes[i]加进去。</p>
<p>最终代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;math.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> p[<span class="hljs-number">100010</span>];<span class="hljs-comment">//每个素数索引</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> dp[<span class="hljs-number">1000010</span>];<span class="hljs-comment">//保存前n个</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> primes[<span class="hljs-number">100010</span>];<span class="hljs-comment">//前m个素数</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Heap</span> &#123;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> index;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> value;<br>&#125;heap[<span class="hljs-number">1000010</span>],*a;<br><span class="hljs-comment">////////////最小堆的相关操作函数</span><br><span class="hljs-keyword">int</span> hs = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sink</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> q = p &lt;&lt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a = heap[p].value, b = heap[p].index;<br>    <span class="hljs-keyword">while</span> (q &lt;= hs) &#123;<br>        <span class="hljs-keyword">if</span> (q &lt; hs &amp;&amp; heap[q + <span class="hljs-number">1</span>].value &lt; heap[q].value) q++;<br>        <span class="hljs-keyword">if</span> (heap[q].value &gt;= a) <span class="hljs-keyword">break</span>;<br>        heap[p].index = heap[q].index;<br>        heap[p].value = heap[q].value;<br>        p = q;<br>        q = p &lt;&lt; <span class="hljs-number">1</span>;<br>    &#125;<br>    heap[p].value = a;<br>    heap[p].index = b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swim</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> q = p &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a = heap[p].value, b = heap[p].index;<br>    <span class="hljs-keyword">while</span> (q &amp;&amp; a &lt; heap[q].value) &#123;<br>        heap[p].index = heap[q].index;<br>        heap[p].value = heap[q].value;<br>        p = q;<br>        q = p &gt;&gt; <span class="hljs-number">1</span>;<br>    &#125;<br>    heap[p].value = a;<br>    heap[p].index = b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Heap* a)</span> </span>&#123;<br>    hs++;<br>    heap[hs].index= a-&gt;index;<br>    heap[hs].value = a-&gt;value;<br>    <span class="hljs-built_in">swim</span>(hs);<br>&#125;<br><span class="hljs-function">Heap <span class="hljs-title">getmin</span><span class="hljs-params">()</span> </span>&#123;<br>    Heap r = heap[<span class="hljs-number">1</span>];<br>    heap[<span class="hljs-number">1</span>] = heap[hs--];<br>    <span class="hljs-built_in">sink</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br><span class="hljs-comment">///////////////////////////////////////</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> m, n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;m, &amp;n);<br>    primes[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>    primes[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">int</span> tot = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">5</span>; tot &lt; m; i++) &#123;<br>        <span class="hljs-keyword">bool</span> is = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= tot &amp;&amp; primes[j] &lt;= <span class="hljs-built_in">sqrt</span>(i); j++) &#123;<br>            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>) &#123;<br>                is = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!is) <span class="hljs-keyword">continue</span>;<br>        primes[++tot] = i;<br>    &#125;<span class="hljs-comment">////求出前m个素数</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    a = (Heap*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(Heap));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;  <br>        a-&gt;index = i;<br>        a-&gt;value = primes[i];<br>        <span class="hljs-built_in">insert</span>(a); <span class="hljs-comment">//把dp[p[i]]*primes[i]的值加入堆，第一次p[i]均为0，dp[0]为1</span><br>    &#125;<br>    tot = <span class="hljs-number">0</span>;<br>    Heap min;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; tot &lt; n; i++) &#123;<br>        min = <span class="hljs-built_in">getmin</span>();<br>        <span class="hljs-keyword">if</span> (min.value &gt; dp[tot]) &#123;<br>            dp[++tot] = min.value; <span class="hljs-comment">//新的丑数加入dp </span><br>            p[min.index]++; <span class="hljs-comment">//对应索引后移</span><br>            min.value = dp[p[min.index]] * primes[min.index];<br>            <span class="hljs-built_in">insert</span>(&amp;min); <span class="hljs-comment">//将新的乘积加入堆</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%llu&quot;</span>, dp[tot]);<br>            <span class="hljs-keyword">if</span> (tot == n)  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>            <span class="hljs-keyword">else</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//不必加入dp，但要把对应索引后移，将新的值加入堆</span><br>            p[min.index]++;<br>            min.value = dp[p[min.index]] * primes[min.index];<br>            <span class="hljs-built_in">insert</span>(&amp;min);<br>        &#125;<br>    &#125;<br><br> &#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="2021-11-28"><a href="#2021-11-28" class="headerlink" title="2021-11-28"></a>2021-11-28</h2><p>我也想刷题啊，可为什么还有那么多事啊😭😭😭😭</p>
<ul>
<li><h4 id="OJ-奶牛的食物"><a href="#OJ-奶牛的食物" class="headerlink" title="OJ.奶牛的食物"></a>OJ.奶牛的食物</h4><p><img src="https://cdn.jsdelivr.net/gh/ziyikee/blog_img/blog_img/202201131353100.png" srcset="/img/loading.gif" lazyload alt="奶牛的食物"></p>
<p>一道状态压缩DP的经典题型，起初的思路就是DP，但是不知道怎么DP😭😭</p>
<p>个人理解，状态压缩DP就是将一个状态表现成一个数位0或1，对应某一块地的用还是不用，而一个数值包含多个位，就可以表示一组状态。</p>
<p>因此，在这道题中，我们就可以使用一个int值来表示一行上的地块能放牛和不能让放牛的状态，一行上的地块选与不选的状态，例如一行上有4列，数字5(0101)，就代表选择第二块和第四块，这样每一行的状态都由一个数字表示。</p>
<p>对于本题，假设一共有n列，则该列的状态一共有(1&lt;&lt;n)种状态，在本题中，要保证选择的两块地不相邻，因此在进行DP过程中，当前行的可选状态，只与上一行的状态有关，要满足下面几个条件：</p>
<ul>
<li>对于当前行的状态j，首先j中不能出现两个地块相邻，即j的数位中不出现两个1相邻，可以通过<code>(j&amp;(j&lt;&lt;1))==0</code>来判断，若为true，说明j满足条件，若为false，说明不满足条件</li>
<li>如果用value[i]来表示第i行的地块的肥沃和贫瘠的情况，1表示可以放牛，0表示不可以放牛，则第i行到的可选状态还必须满足<code>(value[i]|j)==value[j]</code>，若为true，说明j中的1都是来自value[i]中的1，就是说j所选择的地块都是第i行中的可以放牛的肥沃地块</li>
<li>上面两个条件要求当前行的状态要满足哪些条件，当状态j满足的当前行的状态后，要需要与前一行的状态不产生冲突，假设k是满足前一行的一个可选状态，则当前行的状态j需要保证<code>(j&amp;k)==0</code>，才能保证当前行与前一行中不存在上下相邻的行，对于当前行的状态j的方案数，就是所有满足上一行的可选状态且不与j产生冲突的状态方案数的总和</li>
</ul>
<p>在具体代码中，我们用value[]来保存每一行的可以放牛和不可以放牛的状态，用useful[]来保存所有自身不存在冲突的可选状态，即满足<code>j&amp;(j&lt;&lt;1))==0</code>,用dp[i] [j]来表示第i行，状态j的方案数，最后总的方案数就是dp[n] [k]的总和，k为其中的一个状态，具体代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> value[<span class="hljs-number">13</span>];<span class="hljs-comment">//保存读入的每一行的01状态</span><br><span class="hljs-keyword">int</span> useful[<span class="hljs-number">2000</span>];<span class="hljs-comment">//保存所有自身不冲突的状态</span><br><span class="hljs-keyword">int</span> dp[<span class="hljs-number">13</span>][<span class="hljs-number">2000</span>];<span class="hljs-comment">//i行j状态的方案数</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">int</span> m,n,t;<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;m,&amp;n);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>  	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>    	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);<br>      	value[i]=(value[i]&lt;&lt;<span class="hljs-number">1</span>)|t;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">int</span> allstates = (<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">int</span> usefulstates=<span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;=allstates;i++)&#123; <span class="hljs-comment">//这里是进行一个预处理，现将所有自身不冲突的状态保存下来</span><br>  	<span class="hljs-keyword">if</span>((i&amp;(i&lt;&lt;<span class="hljs-number">1</span>))==<span class="hljs-number">0</span>)&#123;<br>    	useful[usefulstates++] = i;<span class="hljs-comment">//将所有本身不冲突的状态保留</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;usefulstates;i++)&#123; <span class="hljs-comment">//初始化第一行的状态</span><br>  	<span class="hljs-keyword">if</span>((value[<span class="hljs-number">1</span>]|useful[i])==value[<span class="hljs-number">1</span>])&#123;  <span class="hljs-comment">//说明useful[i]的状态可以在第一行出现</span><br>    	dp[<span class="hljs-number">1</span>][useful[i]] = <span class="hljs-number">1</span>;  <span class="hljs-comment">//初始化第一行</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i&lt;=m;i++)&#123;<br>  	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j&lt;usefulstates;j++)&#123;<br>    	<span class="hljs-keyword">if</span>((value[i]|useful[j])==value[i])&#123;  <span class="hljs-comment">//对于本身不冲突的状态，判断其是否是当前行的可选状态，满足限制条件2</span><br>        	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;usefulstates;k++)&#123;<br>            	<span class="hljs-keyword">if</span>((useful[j]&amp;useful[k])==<span class="hljs-number">0</span>&amp;&amp;(useful[k]|value[i<span class="hljs-number">-1</span>])==value[i<span class="hljs-number">-1</span>])&#123; <span class="hljs-comment">//判断与前一行是否存在冲突</span><br>                	dp[i][useful[j]] += dp[i<span class="hljs-number">-1</span>][useful[k]];  <span class="hljs-comment">//前一行的状态k，也要满足前一行的可选条件</span><br>                  	dp[i][useful[j]] %=<span class="hljs-number">100000000</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;usefulstates;i++)&#123;<br>  		ans+=dp[m][useful[i]];<br>     ans %=<span class="hljs-number">100000000</span>;  <span class="hljs-comment">//将所有状态的方案数求和</span><br>    &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
</ul>
<h2 id="2021-11-22"><a href="#2021-11-22" class="headerlink" title="2021-11-22"></a>2021-11-22</h2><p>又摸了一天。。。</p>
<ul>
<li><h4 id="剑指offer25-合并两个排序的链表"><a href="#剑指offer25-合并两个排序的链表" class="headerlink" title="剑指offer25.合并两个排序的链表"></a>剑指offer25.合并两个排序的链表</h4><p>easy遍历</p>
</li>
<li><h4 id="剑指offer26-树的子结构"><a href="#剑指offer26-树的子结构" class="headerlink" title="剑指offer26.树的子结构"></a>剑指offer26.树的子结构</h4><p><img src="https://cdn.jsdelivr.net/gh/ziyikee/blog_img/blog_img/202201131354231.png" srcset="/img/loading.gif" lazyload alt="剑指26"></p>
</li>
</ul>
<p>先深度优先遍历找到头结点的值在A树中的位置，然后递归check下面的子树，注意终止条件即可</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    TreeNode d;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSubStructure</span><span class="hljs-params">(TreeNode A, TreeNode B)</span> </span>&#123;<br>        d= B;<br>        <span class="hljs-keyword">if</span>(A==<span class="hljs-keyword">null</span>&amp;&amp;B!=<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">if</span>(A!=<span class="hljs-keyword">null</span>&amp;&amp;B==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">if</span>(A==<span class="hljs-keyword">null</span>&amp;&amp;B==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">return</span> find(A,B.val);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">find</span><span class="hljs-params">(TreeNode r,<span class="hljs-keyword">int</span> k)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(r==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">if</span>(r.val==k) &#123;<br>            <span class="hljs-keyword">boolean</span> ans = check(r,d);<br>            <span class="hljs-keyword">if</span>(ans==<span class="hljs-keyword">true</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>      <span class="hljs-keyword">return</span> find(r.left,k) || find(r.right,k);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">check</span><span class="hljs-params">(TreeNode r,TreeNode x)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(r==<span class="hljs-keyword">null</span>&amp;&amp;x==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span>(r!=<span class="hljs-keyword">null</span>&amp;&amp;x==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span>(r!=<span class="hljs-keyword">null</span>&amp;&amp;x!=<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(r.val == x.val)<br>            &#123;<br>                <span class="hljs-keyword">return</span> check(r.left,x.left)&amp;&amp;check(r.right,x.right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<ul>
<li><h4 id="剑指offer28-对称的二叉树"><a href="#剑指offer28-对称的二叉树" class="headerlink" title="剑指offer28.对称的二叉树"></a>剑指offer28.对称的二叉树</h4><p>easy，递归判断即可</p>
</li>
</ul>
<h2 id="2021-11-20"><a href="#2021-11-20" class="headerlink" title="2021-11-20"></a>2021-11-20</h2><p>学院csp线上测验，未得到完整题解，暂不记录</p>
<h2 id="2021-11-18"><a href="#2021-11-18" class="headerlink" title="2021-11-18"></a>2021-11-18</h2><ul>
<li><h4 id="剑指offer14-1-剪绳子1"><a href="#剑指offer14-1-剪绳子1" class="headerlink" title="剑指offer14-1.剪绳子1"></a>剑指offer14-1.剪绳子1</h4></li>
<li><h4 id="剑指offer14-2-剪绳子2"><a href="#剑指offer14-2-剪绳子2" class="headerlink" title="剑指offer14-2.剪绳子2"></a>剑指offer14-2.剪绳子2</h4><p>数学证明：每次切都切长度3</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cuttingRope</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> n-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">long</span> res = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">long</span> mod =(<span class="hljs-keyword">long</span>)<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br>        <span class="hljs-keyword">while</span>(n&gt;<span class="hljs-number">4</span>)&#123;<br>            res = (res*<span class="hljs-number">3</span>)%mod;<br>            n = n-<span class="hljs-number">3</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)((res*n)%mod);<br>        <br>        &#125;<br>&#125;<span class="hljs-comment">//主要是大数溢出，res和mod都要为long才行</span><br></code></pre></div></td></tr></table></figure>

<p>动态规划（后续补充）</p>
</li>
<li><h4 id="剑指offer-21-调整数组顺序使奇数位于偶数前面"><a href="#剑指offer-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指offer 21.调整数组顺序使奇数位于偶数前面"></a>剑指offer 21.调整数组顺序使奇数位于偶数前面</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;  <span class="hljs-comment">//原地交换</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] exchange(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">int</span>  i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> tem=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> j = nums.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;j)&#123;<br>            <span class="hljs-keyword">if</span>((nums[i]&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">0</span>&amp;&amp;(nums[j]&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">1</span>)&#123;<br>                tem = nums[i];<br>                nums[i] = nums[j];<br>                nums[j] = tem;<br>                i++;<br>                j--;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((nums[i]&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">0</span>&amp;&amp;(nums[j]&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">0</span>)&#123;<br>                j--;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((nums[i]&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">1</span>&amp;&amp;(nums[j]&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">1</span>)&#123;<br>                i++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                i++;j--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
</ul>
<h2 id="2021-11-16"><a href="#2021-11-16" class="headerlink" title="2021-11-16"></a>2021-11-16</h2><ul>
<li><h4 id="剑指offer-27-二叉树的镜像"><a href="#剑指offer-27-二叉树的镜像" class="headerlink" title="剑指offer 27.二叉树的镜像"></a>剑指offer 27.二叉树的镜像</h4><p>easy，递归处理</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">mirrorTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">return</span> reverse(root);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">reverse</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        TreeNode l = root.left;<br>        TreeNode r = root.right;<br>        root.left = reverse(r);<br>        root.right = reverse(l);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
<li><h4 id="剑指offer-11-旋转数组的最小数字"><a href="#剑指offer-11-旋转数组的最小数字" class="headerlink" title="剑指offer 11.旋转数组的最小数字"></a>剑指offer 11.旋转数组的最小数字</h4><p>easy,初始最小设为数组第一个(考虑没有发生旋转的情况)，接着从左往右遍历，当发现下一个比当前的值小，说明下一个是旋转前的头一个，是最小的</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] numbers)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = numbers.length;<br>        <span class="hljs-keyword">int</span> ans = numbers[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;len-<span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(numbers[i]&gt;numbers[i+<span class="hljs-number">1</span>])&#123;<br>                ans = numbers[i+<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
<li><h4 id="剑指offer-12-矩阵中的路径"><a href="#剑指offer-12-矩阵中的路径" class="headerlink" title="剑指offer 12.矩阵中的路径"></a>剑指offer 12.矩阵中的路径</h4><p><img src="https://cdn.jsdelivr.net/gh/ziyikee/blog_img/blog_img/202201131354117.png" srcset="/img/loading.gif" lazyload alt="剑指12"></p>
</li>
</ul>
<p>整体思路：DFS+标记位，自己做的时候有大概的思路，但是还是混乱的，在情况分类，边界条件上做了很多无用功，引以为戒。</p>
<p>DFS的递归思路：</p>
<p>递归变量：当前值在矩阵中的坐标i,j以及当前判断的目标字符串中的字符在数组中的位置</p>
<p>递归函数：</p>
<ol>
<li>首先判断当前的坐标值，是否在正常的坐标范围内，如果不在，返回false，如果在，进一步判断</li>
<li>若当前坐标(i,j)出的字符与目标字符相同，且当前坐标未被使用过，flag[i] [j]为false，进一步处理。若不满足要求，说明找不到目标字符，返回false。</li>
<li>当判断当前位置找到了目标字符时，先将当前位置的标记设为true，即flag[i] [j]为true，接着递归判断当前位置的上下左右四个位置，只要有一个满足情况就说明找到了目标字符串，返回true，否则，说明此路不通，需要将当前位置的标记重新改为false，返回false，只有能走通的路才能被标记位true</li>
<li>如果当前坐标的字符与目标字符相同，且当前坐标未被访问，目标字符在数组中正好是最后一个，说明已经找到了所有的字符，直接返回true</li>
</ol>
<p>初始代码：（极其混乱，注释部分过多代码冗余）</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">char</span>[] c;<br>    <span class="hljs-keyword">char</span>[][] tem;<br>    <span class="hljs-keyword">boolean</span>[][] flag1;<br>    <span class="hljs-keyword">int</span> length;<br>    <span class="hljs-keyword">int</span> M=<span class="hljs-number">0</span>,N=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, String word)</span> </span>&#123;<br>        c = word.toCharArray();<br>        length = c.length;<br>        tem = board;<br>        <span class="hljs-keyword">int</span> m = board.length; <span class="hljs-comment">//hang</span><br>        <span class="hljs-keyword">int</span> n = board[<span class="hljs-number">0</span>].length; <span class="hljs-comment">//lies</span><br>        M = m;<br>        N = n; <br>        <span class="hljs-keyword">boolean</span>[][] flag = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[m][n];<br>        <span class="hljs-keyword">boolean</span> ans = <span class="hljs-keyword">false</span>;<br>        flag1 = flag;<br>        <span class="hljs-keyword">if</span>(m*n&lt;length) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j =<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(tem[i][j]==c[<span class="hljs-number">0</span>])&#123;<br>                     ans = find(i,j,<span class="hljs-number">0</span>);<br>                     <span class="hljs-keyword">if</span>(ans == <span class="hljs-keyword">true</span>)  <span class="hljs-keyword">return</span> ans;<br>                    <span class="hljs-comment">//  for(int a = 0;a&lt;m;a++)&#123;//因为在递归函数里若当前路径没有找到，就会取消标记，因此不用再将所有的标记清除，这会做很多无用功，浪费很多时间</span><br>                    <span class="hljs-comment">//      for(int b = 0;b&lt;n;b++)&#123;</span><br>                    <span class="hljs-comment">//          flag1[a][b] = false;</span><br>                    <span class="hljs-comment">//      &#125;</span><br>                    <span class="hljs-comment">//  &#125;</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j,<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>        <span class="hljs-keyword">boolean</span> ans =<span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-number">0</span>&amp;&amp;i&lt;M&amp;&amp;j&gt;=<span class="hljs-number">0</span>&amp;&amp;j&lt;N)&#123;<br>            <span class="hljs-keyword">if</span>(tem[i][j]==c[x]&amp;&amp;flag1[i][j]==<span class="hljs-keyword">false</span>)&#123;<br>                flag1[i][j] = <span class="hljs-keyword">true</span>;<br>                <span class="hljs-keyword">if</span>(x==length-<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                <span class="hljs-comment">// if(i==0&amp;&amp;j==0)&#123;</span><br>                <span class="hljs-comment">//     ans = find(i+1,j,x+1)||find(i,j+1,x+1);</span><br>                <span class="hljs-comment">//     if(ans == true) return true;</span><br>                <span class="hljs-comment">//     flag1[i][j] = false;</span><br>                <span class="hljs-comment">//    // return false;</span><br>                <span class="hljs-comment">//  &#125;</span><br>                <span class="hljs-comment">// if(i==0&amp;&amp;j!=0)&#123;  //因为在一开始会判断坐标是否处于正常的范围，因此不需要在针对坐标做分类处理了，统一去找上下所有即可</span><br>                <span class="hljs-comment">//   ans = find(i,j-1,x+1)||find(i,j+1,x+1)||find(i+1,j,x+1);</span><br>                <span class="hljs-comment">//   if(ans == true) return true;</span><br>                <span class="hljs-comment">//   flag1[i][j] = false;</span><br>                <span class="hljs-comment">//   //return false;</span><br>                <span class="hljs-comment">// &#125;</span><br>                <span class="hljs-comment">// if(i!=0&amp;&amp;j==0)&#123;</span><br>                <span class="hljs-comment">//    ans = find(i-1,j,x+1)||find(i+1,j,x+1)||find(i,j+1,x+1);</span><br>                <span class="hljs-comment">//    if(ans == true) return true;</span><br>                <span class="hljs-comment">//     flag1[i][j] = false;</span><br>                <span class="hljs-comment">//     //return false;</span><br>                <span class="hljs-comment">// &#125;</span><br>                <span class="hljs-comment">// if(i!=0&amp;&amp;j!=0)&#123;</span><br>                ans =  find(i-<span class="hljs-number">1</span>,j,x+<span class="hljs-number">1</span>)||find(i+<span class="hljs-number">1</span>,j,x+<span class="hljs-number">1</span>)||find(i,j+<span class="hljs-number">1</span>,x+<span class="hljs-number">1</span>)||find(i,j-<span class="hljs-number">1</span>,x+<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(ans == <span class="hljs-keyword">true</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                flag1[i][j] = <span class="hljs-keyword">false</span>;<br>                <span class="hljs-comment">//return false;</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br> &#125;<br></code></pre></div></td></tr></table></figure>

<p>最终版：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">char</span>[] c;<br>    <span class="hljs-keyword">char</span>[][] tem;<br>    <span class="hljs-keyword">boolean</span>[][] flag1;<br>    <span class="hljs-keyword">int</span> length;<br>    <span class="hljs-keyword">int</span> M=<span class="hljs-number">0</span>,N=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, String word)</span> </span>&#123;<br>        c = word.toCharArray();<br>        length = c.length;<br>        tem = board;<br>        <span class="hljs-keyword">int</span> m = board.length; <span class="hljs-comment">//hang</span><br>        <span class="hljs-keyword">int</span> n = board[<span class="hljs-number">0</span>].length; <span class="hljs-comment">//lies</span><br>        M = m;<br>        N = n; <span class="hljs-comment">//保存一些全局变量，包括矩阵的行数和列数，目标字符串数组，标记矩阵等等</span><br>        <span class="hljs-keyword">boolean</span>[][] flag = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[m][n];<br>        <span class="hljs-keyword">boolean</span> ans = <span class="hljs-keyword">false</span>;<br>        flag1 = flag;<br>        <span class="hljs-keyword">if</span>(m*n&lt;length) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j =<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(tem[i][j]==c[<span class="hljs-number">0</span>])&#123;  <span class="hljs-comment">//刚开始找第一个字符的时候，应该尝试对所有与目标字符串第一个字符相等的坐标</span><br>                     ans = find(i,j,<span class="hljs-number">0</span>);<br>                     <span class="hljs-keyword">if</span>(ans == <span class="hljs-keyword">true</span>)  <span class="hljs-keyword">return</span> ans;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j,<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>        <span class="hljs-keyword">boolean</span> ans =<span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-number">0</span>&amp;&amp;i&lt;M&amp;&amp;j&gt;=<span class="hljs-number">0</span>&amp;&amp;j&lt;N)&#123;<br>            <span class="hljs-keyword">if</span>(tem[i][j]==c[x]&amp;&amp;flag1[i][j]==<span class="hljs-keyword">false</span>)&#123;<br>                flag1[i][j] = <span class="hljs-keyword">true</span>;<br>                <span class="hljs-keyword">if</span>(x==length-<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                ans =  find(i-<span class="hljs-number">1</span>,j,x+<span class="hljs-number">1</span>)||find(i+<span class="hljs-number">1</span>,j,x+<span class="hljs-number">1</span>)||find(i,j+<span class="hljs-number">1</span>,x+<span class="hljs-number">1</span>)||find(i,j-<span class="hljs-number">1</span>,x+<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(ans == <span class="hljs-keyword">true</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                flag1[i][j] = <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>   &#125;<br> &#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="2021-11-15"><a href="#2021-11-15" class="headerlink" title="2021-11-15"></a>2021-11-15</h2><ul>
<li><h4 id="剑指offer-05-替换空格-very-easy"><a href="#剑指offer-05-替换空格-very-easy" class="headerlink" title="剑指offer 05.替换空格    very easy"></a>剑指offer 05.替换空格    very easy</h4></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ziyikee/blog_img/blog_img/202201131354541.png" srcset="/img/loading.gif" lazyload alt="剑指05"></p>
<p>对于java的string类型，它具有不可变型，使用StringBuilder类型保存结果，遍历s的每个        字符，当遇到空格使，向StringBuilder中加入“%20”，其他情况，加入当前字符。</p>
<p>主要是好久不做，相关API忘记了。。。</p>
<p>这里需要复习一下String，StringBuilder，和Stringbuffer的异同。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">replaceSpace</span><span class="hljs-params">(String s)</span> </span>&#123;<br>            StringBuilder  ans = <span class="hljs-keyword">new</span> StringBuilder();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c:s.toCharArray())<br>            &#123;<br>                <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                    ans.append(<span class="hljs-string">&quot;%20&quot;</span>);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    ans.append(c);<br>                &#125;<br>            &#125; <br>            <span class="hljs-keyword">return</span> ans.toString();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<ul>
<li><h4 id="剑指offer-07-重建二叉树"><a href="#剑指offer-07-重建二叉树" class="headerlink" title="剑指offer 07.重建二叉树"></a>剑指offer 07.重建二叉树</h4><p><img src="https://cdn.jsdelivr.net/gh/ziyikee/blog_img/blog_img/202201131354098.png" srcset="/img/loading.gif" lazyload alt="剑指07"></p>
</li>
</ul>
<p>关于本题的关键点：</p>
<ol>
<li>前序遍历第一个就是根节点，中序遍历的根节点左边就是左子树，右边就是右子树</li>
<li>前序遍历的结构是[根节点，左子树，右子树]，且左子树和右子树部分的第一个分别是他们的根节点</li>
<li>中序遍历的结构是[左子树，根节点，右子树]</li>
<li>所以可以根据这样的结构去递归处理左子树和右子树</li>
</ol>
<p>难点主要在于递归的结构，在递归过程中需要传递的变量值，这里使用一个HashMap来存储中序遍历中每个节点值和它在中序遍历的数组中的位置，这样可以在O(1)的条件下获取一个值在中序遍历中的索引。</p>
<p>递归算法分析：</p>
<ul>
<li><p>递归参数：</p>
<p>root_pre_id：表示根节点在前序遍历中的索引，根据这个id可以获得当前树根节点的值，再根据根节点的值，可以在map中得到在根节点在中序遍历中的索引.</p>
<p>in_left：当前树在中序遍历中的左边界</p>
<p>in_right：当前树在中序遍历中的右边界</p>
<p>根据上述三个参树，每次递归都可以计算出左节点或右节点在前序遍历中的索引，以及左右子树各自的左右边界。</p>
</li>
<li><p>终止条件：in_left&gt;in_right，说明已将越过了叶子结点，返回null</p>
</li>
<li><p>每一次递归：</p>
<ol>
<li><p>计算根据root_pre_id，得到根节点的值，建立根节点</p>
</li>
<li><p>根据根节点的值，得到根节点在中序遍历中的索引root_in_id</p>
</li>
<li><p>递归左右子树：</p>
<p>递归变量：</p>
<p>左子树：左子树根节点在前序遍历中的索引就是当前根节点在前序中的索引+1，即root_pre_id + 1,左子树在中序中的左边界就是当前的左边界，即in_left+1，右边界为当前根节点在中序中的索引-1，即root_in_id - 1</p>
<p>右子树：右子树的根节点在前序遍历中的索引就是当前根节点在前序中的索引加上左子树的节点数量+1，即root_pre_id+(root_in_id - in_left) + 1，右子树的左边界为root_in_id +1，右边界为当前的右边界in_right</p>
</li>
<li><p>返回root</p>
</li>
</ol>
</li>
</ul>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] pre;<br>    <span class="hljs-keyword">private</span> HashMap&lt;Integer,Integer&gt; id_index = <span class="hljs-keyword">new</span> HashMap&lt;Integer,Integer&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span>[] inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.pre = preorder;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;inorder.length;i++)&#123;<br>            id_index.put(inorder[i],i);  <span class="hljs-comment">//使用map保存中序数组中的值与索引，避免每一次都遍历</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> build(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,inorder.length-<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> root_pre_id,<span class="hljs-keyword">int</span> in_left,<span class="hljs-keyword">int</span> in_right)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(in_left &gt; in_right)&#123;  <span class="hljs-comment">//终止条件</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        TreeNode root = <span class="hljs-keyword">new</span> TreeNode();  <span class="hljs-comment">//创建当前的根节点</span><br>        root.val = pre[root_pre_id]; <span class="hljs-comment">//获取根节点的值</span><br>        <span class="hljs-keyword">int</span> root_in_id = id_index.get(root.val);  <span class="hljs-comment">//获取根节点在中序中的索引</span><br>        root.left = build(root_pre_id+<span class="hljs-number">1</span>,  in_left,  root_in_id-<span class="hljs-number">1</span>); <span class="hljs-comment">//递归左右子树(根节点的前序索引，中序左边界，中序右边界)</span><br>        root.right = build(root_pre_id+(root_in_id-in_left)+<span class="hljs-number">1</span>,  root_in_id+<span class="hljs-number">1</span>,  in_right);<br>        <span class="hljs-keyword">return</span> root;       <span class="hljs-comment">//根节点前序索引+左子树节点数+1</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<ul>
<li><h4 id="剑指offer-09-用两个栈实现队列"><a href="#剑指offer-09-用两个栈实现队列" class="headerlink" title="剑指offer 09 用两个栈实现队列"></a>剑指offer 09 用两个栈实现队列</h4><p>思路：先用第一个栈保存数据，从队列尾部添加数据，就是把数据push到第一个栈中，当需要从队列头部取出数据时，现将第一个栈中的数据全部pop到第二个栈中，这样第二个栈的栈顶，就是队列头部的元素，pop出栈顶，再把剩下的元素在pop+push导到第一个站里面</p>
</li>
<li><h4 id="剑指offer-10-青蛙跳台阶"><a href="#剑指offer-10-青蛙跳台阶" class="headerlink" title="剑指offer 10 青蛙跳台阶"></a>剑指offer 10 青蛙跳台阶</h4><p>简单DP</p>
</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E5%88%B7%E9%A2%98/">算法与刷题</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/">刷题记录</a>
                    
                  </div>
                
              </div>
              <!-- 
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
               -->
              <p class="note note-warning">
                <strong>本文作者: </strong><a href="/">ziyikee</a> <br>
                <strong>本文链接: </strong><a href="/2021/11/15/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/">https://ziyikee.fun/2021/11/15/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</a> <br>
                <!-- <strong>本文链接: </strong><a href="{{ url_for(page.path) }}" title="{{ page.title }}">{{ page.permalink }}</a> -->
                <strong>版权声明: </strong>本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                   </p>
                   
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/11/16/%E4%BA%94-Redis%E4%BA%8B%E5%8A%A1/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">五.Redis事务与乐观锁</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/11/11/%E5%9B%9B-Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">
                        <span class="hidden-mobile">四.Redis数据类型</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"Yax4VGrJCLUimOwWC0IUwUBl-gzGzoHsz","appKey":"mkp5UxNkruz1T9ByVFewLjOi","path":"window.location.pathname","placeholder":"嘿嘿，说两句吧","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":true,"recordIP":false,"serverURLs":"https://yax4vgrj.lc-cn-n1-shared.com","emojiCDN":null,"emojiMaps":null,"enableQQ":null},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          Fluid.plugins.initFancyBox('#valine .vcontent img:not(.vemoji)');
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="javascript:" rel="nofollow noopener"><span>zyk的小破站</span></a> <i class="iconfont icon-love"></i> <a href="javascript:" rel="nofollow noopener"><span>Blog by ziyikee</span></a> <div> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  
  <!-- 备案信息 -->
  <div class="beian">
    <span>
      <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
        冀ICP备2021024422号
      </a>
    </span>
    
  </div>


  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    
      <script  src="/js/img-lazyload.js" ></script>
    
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>


  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>












  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?41fc030db57d5570dd22f78997dc4a7e";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  
    <!-- Google Analytics -->
    <script defer>
      window.ga = window.ga || function () { (ga.q = ga.q || []).push(arguments) };
      ga.l = +new Date;
      ga('create', 'G-TKFRYZGQQM', 'auto');
      ga('send', 'pageview');
    </script>
    <script async src='https://www.google-analytics.com/analytics.js'></script>
  

  

  

  

  




  
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/timeDate.js"></script>
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/caidai.js"></script>



<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
